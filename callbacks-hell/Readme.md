*Источник на [github](https://github.com/maxogden/callback-hell)*

# Ад обратных вызовов

*руководство для написания асинхронных программ на JavaScript*

## Что такое *Ад обратных вызовов*?

Асинхронный JavaScript или JavaScript который использует обратные вызовы, это то, в чем трудно разобраться интуитивно. Много кода заканчивается тем, что вы видите ниже:

```JavaScript

fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})

```

Видите форму пирамиды и все `})` в конце? Иу!!! Это ласково знают как **Ад обратных вызовов**.

Причина ада обратных вызовов это когда люди пытаются писать JavaScript таким способом когда выполнение происходит визуально сверху вниз. Многие люди делают эту ошибку! В таких языках программирования как C, Ruby или Python на этом месте есть ожидание njuj, что В других языках, таких как C, Ruby или Python есть ожидание того, что все, что происходит на линии 1 завершится перед кодом на линии 2 и начнет исполняться, и так далее вниз до конца файла. Как вы знаете, JavaScript совсем другой.

## Что такое обратные вызовы?

Обратные вызовы это просто соглашение по наименованию для использования функций в JavaScript. Это не специальная вещь названная "обратные вызовы" в языке JavaScript, это просто соглашение. Вместо того, чтобы сразу же вернуть какой-то результат, как и большинство функций, функции, использующие обратные вызовы занимают некоторое время для получения результата. Слово "асинхронный" ака "async" просто способ "занять некоторое время" или "случится в будущем, не прямо сейчас". обычно обратные вызовы используются только при выполнении ввода-вывода [*прим.перев.* I/O -- input-output], например, загрузка вещей, чтение файлов, разговор с базами данных и т.д.

Когда вы вызываете нормальную функцию, вы можете использовать её возвращаемое значение:

```JavaScript

var result = multiplyTwoNumbers(5, 10)
console.log(result)
// 50 gets printed out
```
Однако функции, которые асинхронны и используют обратные вызовы, ничего не возвращают сразу же.

```JavaScript
var photo = downloadPhoto('http://coolcats.com/cat.gif')
// photo is 'undefined'!
```

В данном случае скачивание файла может занять очень много времени, и вы не хотите чтобы ваша программа приостановилась (заблокировалась) пока вы ждете окончания загрузки.

Вместо этого вы сохраните код, который должен выполняться после завершения загрузки в функцию. **Это обратный вызов!** Вы отдаете это функции `downloadPhoto` и это запустит наш обратный вызов (например, "перезвоню тебе позже") когда скачивание завершится и передаст фото (или ошибку если что-нибудь пойдет не так).

```JavaScript
downloadPhoto('http://coolcats.com/cat.gif', handlePhoto)

function handlePhoto (error, photo) {
  if (error) console.error('Download error!', error)
  else console.log('Download finished', photo)
}

console.log('Download started')
```

Самой большой проблемой людей при попытке понять функции обратного вызова -- это отсутствие понимания в каком порядке исполняются вещи при работе программы. В нашем примере произошло три крупные вещи. Сперва функция `handlePhoto` была объявлена, потом функция `downloadPhoto` была запущена и передала `handlePhoto` в качестве обратного вызова, и накнец `'Download started'` была выведена.

Обратите внимание, что `handlephoto` еще не вызывается, она просто создана и передается в качестве обратного вызова в `downloadPhoto`. Но это не будет выполнено до тех пор, пока `downloadPhoto` не закончит делать свою задачу, которая может занять длительное время в зависимости от того, насколько быстрое у вас подключение к Интернету.


Этот пример предназначен для демонстрации двух важных понятий:

-  Обратный вызов `handlePhoto` это просто способ хранить какие-то дела на более позднее время
- Порядок, в котором вещи выполняются, не читаются сверху вниз, он прыгает вокруг на основе, когда вещи в комплекте

## Как я могу исправить ад обратных вызовов?

Ад обратных вызовов вызван плохой практикой кодирования. К счастью писать хороший код не сложно!

Вам нужно всего лишь следовать трем правилам:

### 1. Делайте свой код неглубоким

Вот немного неряшливости в браузер с JavaScript который использует [browser-request](https://github.com/iriscouch/browser-request) чтобы создать AJAX запрос на сервер:

```JavaScript

var form = document.querySelector('form')
form.onsubmit = function (submitEvent) {
  var name = document.querySelector('input').value
  request({
    uri: "http://example.com/upload",
    body: name,
    method: "POST"
  }, function (err, response, body) {
    var statusMessage = document.querySelector('.status')
    if (err) return statusMessage.value = err
    statusMessage.value = body
  })
}

```

Этот код имеет две анонимные функции. Давайте дадим им имена!

```JavaScript

var form = document.querySelector('form')
form.onsubmit = function formSubmit (submitEvent) {
  var name = document.querySelector('input').value
  request({
    uri: "http://example.com/upload",
    body: name,
    method: "POST"
  }, function postResponse (err, response, body) {
    var statusMessage = document.querySelector('.status')
    if (err) return statusMessage.value = err
    statusMessage.value = body
  })
}

```

Как вы видите, давать имена функциям легко и это дает неоспоримые преимущества:

- облегчает чтение кода благодаря описательным именам функций
- исключения возможны когда вы будете получать следы стеков(stacktraces) которые будут ссылаться на фактические имена функций вместо "анонимных".
- позволяет перемещать функций и ссылаться на них по именам

Теперь вы можете переместить функции на верхний уровень нашей программы:

```JavaScript
document.querySelector('form').onsubmit = formSubmit

function formSubmit (submitEvent) {
  var name = document.querySelector('input').value
  request({
    uri: "http://example.com/upload",
    body: name,
    method: "POST"
  }, postResponse)
}

function postResponse (err, response, body) {
  var statusMessage = document.querySelector('.status')
  if (err) return statusMessage.value = err
  statusMessage.value = body
}
```

Обратите внимание что объявление `function` здесь было определено в самом низу файла. Это благодаря (поднятию функций(function hoisting))[https://gist.github.com/maxogden/4bed247d9852de93c94c].

### 2. Модульность

Это самая важная часть: *Любой способен создавать модули*(ака библиотеки). Цитата [Isaac Schlueter](https://twitter.com/izs) (из проекта node.js): "*Пишите маленькие модули, каждая из которых делают одну вещь и собирайте их в другие модули, которые делают большие вещи. Вы не сможете попасть в ад обратных вызовов, если вы не пойдете туда сами.*"

Давайте возьмем шаблонный код сверху и превратим его в модуль, разделив на несколько файлов. Я покажу модульный паттерн, который работает с любым браузерным или серверным кодом (или работаем и там, и там). Наш новый файл называется "formuploader.js" которая содержит наши две фунции:

```JavaScript

module.exports.submit = formSubmit

function formSubmit (submitEvent) {
  var name = document.querySelector('input').value
  request({
    uri: "http://example.com/upload",
    body: name,
    method: "POST"
  }, postResponse)
}

function postResponse (err, response, body) {
  var statusMessage = document.querySelector('.status')
  if (err) return statusMessage.value = err
  statusMessage.value = body
}

```

`module.exports` это небольшой пример модуля из модульной системы node.js которая работает на node, Electron и браузер использует [browserify](https://github.com/substack/node-browserify). Мне очень нравится этот модульный стиль потому что он работает везде, очень легко в понимании и не требует сложных конфигурационных файлов и скриптов.

Теперь у нас есть `formuploader.js` (и он будет загружен на страницу в тег script после запуска browserified) нам просто нужно потребовать и использовать его!

```JavaScript
var formUploader = require('formuploader')
document.querySelector('form').onsubmit = formUploader.submit
```

Теперь наше приложение имеет только две строки кода и имеет следующие преимущества:

- легок к пониманию для новых разработчиков -- они нигде не увязнут читая все функции `formuploader`
- `formuploader` может быть использован в других местах без дублирования кода и легко выложен на github или npm.

### Обрабатывайте каждую ошибку

Есть различные типы ошибок: синтаксические ошибки вызванные программистом (обычно ловятся при попытке первого запуска программы), ошибки во время исполнения из-за программиста (код начал выполняться, но какая-то ошибка всё испортила), ошибки платформы вызванные неверным разрешением файла, сбои в работе жесткого диска, отсутствие интернет соединения и т.д.

Первые два правила это прежде всего то, что ваш код должен быть читаемым, но это делает код устойчивым. Когда мы имеем дело с обратными вызовами, вы по определению имеете дело с задачами, которые были отправлены, ушли и сделали что-то в фоновом режиме, и успешно завершатся или прервется из-за ошибки. Любой опытный разработчки скажет вам, что вы никогда не сможете предугадать, когда эти ошибки произойдут, поэтому вы всегда должны иметь в запасе план на такие случаи.

С обратными вызовами самым популярным способом обработать ошибки является стиль Node.js, где первый параметр обратного вызова всегда резервируется для ошибок.

```JavaScript
var fs = require('fs')

fs.readFile('/Does/not/exist', handleFile)

function handleFile (error, file) {
  if (error) return console.error('Uhoh, there was an error', error)
  // в противном случае, продолжай и используй 'file' в своем коде
}
```
Первый аргумент будет `error` в первом соглашении, что не даст вам забыть обработать свои ошибки. Если бы это был второй аргумент, то вы могли бы написать код как `function handleFile (file) { }` и легко пропустить ошибку.

Линтеры кода также можно настроить, чтобы помочь вам не забывать обрабатывать ошибки обратного вызова. Самый простой в использовании это [стандарт](http://standardjs.com/). Все, что вам нужно сделать, это запустить `$ standard` в своей папке с кодом и он покажет вам каждый обратный вызов с необработанной ошибкой.

## Краткий итог

1. Не вкладывайте функции. Дайте им имена и разместите их на верхнем уровне программы
2. Используйте [поднятие функций(function hoisting)](https://gist.github.com/maxogden/4bed247d9852de93c94c) для своего преимущества в перемещении функций 'ниже сгиба'.
3. Обрабатывайте **каждую ошибку** в каждом ваше обратном вызове. Используйте линтер [стандарт](http://standardjs.com/) для помощи себе в этом.
4. Создавайте повторноиспользуемые функции и помещайте их в модули, чтобы уменьшить когнитивную нагрузку требуемую для понимания вашего кода. Разделяйте ваш код на маленькие кусочки, это так же поможем вам обрабатывать ошибки, писать тесты, вынудит вас создавать стабильный и задокументированный публичный API для вашего кода, и поможет с его рефакторингом.

Самый важный аспект ухода от ада обратных вызовов это **перемещение функций за пределы пути** так, что поток программы будет более понятен без первопроходцев, которым необходимо пробираться через все подробности функций, чтобы добраться до сути того, что программа пытается сделать.

Вы можете начать перемещать функции в конец файла, затем переместить их в другой файл который вы будете загружать как `require('./photo-helpers.js')` и затем переместить их в отдельный модуль как `require('image-resize')`.

Вот некоторые эмпирические правила при создании модуля:

- Начните с перемещения неоднократно использованного кода в функцию
- Когда ваша функция (или группа функци связанных одной темой) получится достаточно большой, переместите их в другой файл и вызывайте используя `module.exports`. Вы можете загружать его используя относительный вызов
- Если у вас есть некоторый код, который может быть использован в нескольких проектах, создайте ему собственный readme, тест и `package.json` и опубликуйте его на github и npm. У этого подхода так много преимуществ, что не будем перечислять их здесь.
- Хороший модуль небольшой и фокусируется на одной проблеме.
- В файле модуля не должно быть больше 150 строчек кода
- Модуль не должен иметь более одного уровня вложенности папок или JavaScript файлов. Если это произошло, то, вероятно, ваш модуль делает слишком много вещей
- Просите более опытных программистов показать вам примеры хороших модулей чтобы у вас сложилось хорошее представление о том как они должны выглядеть. Если понимание того, что происходит в модуле, занимает больше времени чем несколько минут, то это не очень хороший модуль.

## Что читать

Попробуйте прочесть мое [большое введение в обратные вызовы](https://github.com/maxogden/art-of-node#callbacks) или попробуйте пройти несколько уроков в [nodeschool](http://nodeschool.io/ru/).

Так же прочтите [карманный справочник browserify](https://github.com/substack/browserify-handbook) в каечтсве примера как писать модульный код.

## А что насчет промисов, генераторов, es6?

Прежде чем рассматривать более продвинутые решения, помните что обратные вызовы это фундаментальная часть JavaScript (поскольку они являются просто функциями) и вы должны научиться читать и писать их, прежде чем переходить к более продвинутым функциям языка, поскольку все они зависят от понимания обратных вызовов. Если вы не можете написать удобный для поддержки код обратных вызовов, то продолжайте работать над этим!

Если вы действительно хотите, чтобы ваш асинхронный код читаелся сверху вниз, то есть некоторые необычные вещи, которые вы можете попробовать. Обратите внимание что **они могут ввести производительность и/или возникнуть кроссплатформенные проблемы совместимости во время выполнения**, поэтому убедитесь, что вы все предусмотрели.

**Промисы** -- это путь написания асинхронного кода, который выглядит так, будто он исполняется сверху вниз, иобрабатывает больше типов ошибок из-за использования `try/catch` стиля обработки ошибок.

**Генераторы** позволяют вам 'приостановить' отдельную функцию без приостановки всей программы, который за счет чуть более сложного для понимания кода позволяет вашему асинхронному коду появится для выполнения в стиле сверху-вниз. Посмотрите [watt](https://github.com/mappum/watt) для примера такого подхода.

**Асинхронные функции** -- предложенная особенность ES7, которая далее обернет генераторы и промисы в высокоуровневый синтаксис. Посмотрите, если это звучит интересно для вас.

Лично я использую обратные вызовы в 90% случаях когда пишу асинхронный код и, когда все становится сложно, я произвожу в нечто вроде [run-parallel](https://github.com/feross/run-parallel) или [run-series](https://github.com/feross/run-series). Я не думаю, что обратные вызовы против промисов и против всего остального действительно имеют значение для меня, большим влиянием будет сохранение кода простым, не вложенным и разделенным на маленькие модули.

Независимо от метода, который вы выберите, всегда **обрабатывайте ошибки** и **делайте свой код простым**.

**Помните, только *вы* можете предотвратить ад обратных вызовов и лесные пожары.**
