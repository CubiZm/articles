*Источник на [github](https://github.com/maxogden/callback-hell)*

# Ад обратных вызовов

*руководство для написания асинхронных программ на JavaScript*

## Что такое *Ад обратных вызовов*?

Асинхронный JavaScript или JavaScript который использует обратные вызовы, это то, в чем трудно разобраться интуитивно. Большое количсетво кода заканчивается вот так:

```JavaScript

fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})

```

Видите форму пирамиды и все `})` в конце? Иу!!! Это ласково называют **Адом обратных вызовов**.

Причина ада обратных вызовов кроется в том, что люди пытаются писать JavaScript таким способом когда выполнение происходит визуально сверху вниз. Многие люди делают эту ошибку! В других языках, таких как C, Ruby или Python многие люди ожидают что то,что происходит на строке 1 завершится перед тем, как выполнение перейдет на строку 2 и так далее вниз до конца файла. Как вы узнаете, JavaScript совсем другой.

## Что такое обратные вызовы?

Обратные вызовы это общепринятое название для функций в JavaScript. Это не особая функция, которую мы назваем "обратный вызов", а просто соглашение. Вместо того, чтобы сразу же вернуть какой-то результат, как и большинство функций, функции, использующие обратные вызовы требуют время для получения результата. Слово "асинхронный" или "async" значит, что что-то "занимает какое-то время" или "случится в будущем, не сейчас". Обычно обратные вызовы используются только при выполнении ввода-вывода [*прим.перев.* I/O -- input-output], например, при загрузке, чтении файлов, обменом информации с базами данных и т.д.

Когда вы вызываете обычную функцию, вы можете использовать её возвращаемое значение:

```JavaScript

var result = multiplyTwoNumbers(5, 10)
console.log(result)
// 50 gets printed out
```
Однако асинхронные функции, которые используют обратные вызовы, ничего не возвращают сразу же.

```JavaScript
var photo = downloadPhoto('http://coolcats.com/cat.gif')
// photo is 'undefined'!
```

В данном случае скачивание файла может занять очень много времени, а вы не хотите чтобы ваша программа приостановилась (заблокировалась) пока вы ждете окончания загрузки.

Вместо этого вы сохраняете в функцию код, который должен выполняться после завершения загрузки. **Это обратный вызов!** Вы передаете это функции `downloadPhoto` и это запускает наш обратный вызов (например, "перезвоню тебе позже") когда скачивание завершится и передаст фото (или ошибку если что-нибудь пойдет не так).

```JavaScript
downloadPhoto('http://coolcats.com/cat.gif', handlePhoto)

function handlePhoto (error, photo) {
  if (error) console.error('Download error!', error)
  else console.log('Download finished', photo)
}

console.log('Download started')
```

Самой большой проблемой людей при попытке понять функции обратного вызова -- это отсутствие понимания в каком порядке исполняются функции при работе программы. В нашем примере произошло три крупных события. Сперва функция была объявлена функция `handlePhoto`, потом функция `downloadPhoto` была запущена и она передала `handlePhoto` в качестве обратного вызова. Наконец была выведена функция `'Download started'`.

Обратите внимание, что `handlephoto` еще не вызывается, она просто создана и передается в качестве обратного вызова в `downloadPhoto`. Но она не будет выполнена до тех пор, пока `downloadPhoto` не завершит выполнение своей задачи, которая может занять длительное время в зависимости от того, насколько быстрое у вас подключение к Интернету.


Этот пример предназначен для демонстрации двух важных понятий:

- Обратный вызов `handlePhoto` -- это просто способ отложить какие-то дела на более позднее время
- Функции выполняются не сверху вниз, а асинхронно, по мере выполнения функции

## Как выбраться из ада обратных вызовов?

Этот ужас вызван недостаточной практикой кодирования. К счастью писать хороший код не сложно!

Вам нужно всего лишь следовать трем правилам:

### 1. Не используйте большую вложенность

Вот пример неряшливого кода который использует [browser-request](https://github.com/iriscouch/browser-request) чтобы создать AJAX запрос на сервер:

```JavaScript

var form = document.querySelector('form')
form.onsubmit = function (submitEvent) {
  var name = document.querySelector('input').value
  request({
    uri: "http://example.com/upload",
    body: name,
    method: "POST"
  }, function (err, response, body) {
    var statusMessage = document.querySelector('.status')
    if (err) return statusMessage.value = err
    statusMessage.value = body
  })
}

```

Этот код имеет две анонимные функции. Давайте дадим им имена!

```JavaScript

var form = document.querySelector('form')
form.onsubmit = function formSubmit (submitEvent) {
  var name = document.querySelector('input').value
  request({
    uri: "http://example.com/upload",
    body: name,
    method: "POST"
  }, function postResponse (err, response, body) {
    var statusMessage = document.querySelector('.status')
    if (err) return statusMessage.value = err
    statusMessage.value = body
  })
}

```

Как видите, давать имена функциям легко и это имеет неоспоримые преимущества:

- облегчает чтение кода благодаря описательным именам функций
- при исключениях вы получите следы стеков(stacktraces) которые будут ссылаться на фактические имена функций вместо "анонимных".
- позволяет перемещать функций и ссылаться на них по именам

Теперь вы можете переместить функции на верхний уровень нашей программы:

```JavaScript
document.querySelector('form').onsubmit = formSubmit

function formSubmit (submitEvent) {
  var name = document.querySelector('input').value
  request({
    uri: "http://example.com/upload",
    body: name,
    method: "POST"
  }, postResponse)
}

function postResponse (err, response, body) {
  var statusMessage = document.querySelector('.status')
  if (err) return statusMessage.value = err
  statusMessage.value = body
}
```

Обратите внимание что объявление `function` здесь было определено в самом низу файла. Это произошло благодаря (поднятию функций(function hoisting))[https://gist.github.com/maxogden/4bed247d9852de93c94c].

### 2. Модульность

Это самая важная часть: *Любой способен создавать модули*(или библиотеки). Цитируя [Isaac Schlueter](https://twitter.com/izs) (из проекта node.js): "*Пишите маленькие модули, каждый из которых выполняет одну функцию и собирайте их в другие более крупные модули. Вы не сможете попасть в ад обратных вызовов, если вы не пойдете туда сами.*"

Давайте возьмем шаблонный код сверху и превратим его в модуль, разделив на несколько файлов. Я покажу модульный паттерн, который работает с любым браузерным или серверным кодом (или работаем и там, и там). Наш новый файл называется "formuploader.js" которая содержит наши две фунции:

```JavaScript

module.exports.submit = formSubmit

function formSubmit (submitEvent) {
  var name = document.querySelector('input').value
  request({
    uri: "http://example.com/upload",
    body: name,
    method: "POST"
  }, postResponse)
}

function postResponse (err, response, body) {
  var statusMessage = document.querySelector('.status')
  if (err) return statusMessage.value = err
  statusMessage.value = body
}

```

`module.exports` это небольшой пример модуля из модульной системы node.js которая работает на node, Electron и браузер использует [browserify](https://github.com/substack/node-browserify). Мне очень нравится этот модульный стиль потому что он работает везде, очень легко в понимании и не требует сложных конфигурационных файлов и скриптов.

Теперь у нас есть `formuploader.js` (и он будет загружен на страницу в тег script после запуска browserified) нам просто нужно потребовать и использовать его!

```JavaScript
var formUploader = require('formuploader')
document.querySelector('form').onsubmit = formUploader.submit
```

Теперь наше приложение имеет только две строки кода и имеет следующие преимущества:

- легок к пониманию для новых разработчиков -- они нигде не увязнут читая все функции `formuploader`
- `formuploader` может быть использован в других местах без дублирования кода и легко выложен на github или npm.

### Обрабатывайте каждую ошибку

Есть различные типы ошибок: синтаксические ошибки вызванные программистом (обычно ловятся при попытке первого запуска программы), ошибки во время исполнения из-за программиста (код начал выполняться, но какая-то ошибка всё испортила), ошибки платформы вызванные неверным разрешением файла, сбои в работе жесткого диска, отсутствие интернет соединения и т.д.

Первые два правила это прежде всего то, что ваш код должен быть читаемым, но это делает код устойчивым. Когда мы имеем дело с обратными вызовами, вы по определению имеете дело с задачами, которые были отправлены, ушли и сделали что-то в фоновом режиме, и успешно завершатся или прервется из-за ошибки. Любой опытный разработчки скажет вам, что вы никогда не сможете предугадать, когда эти ошибки произойдут, поэтому вы всегда должны иметь в запасе план на такие случаи.

С обратными вызовами самым популярным способом обработать ошибки является стиль Node.js, где первый параметр обратного вызова всегда резервируется для ошибок.

```JavaScript
var fs = require('fs')

fs.readFile('/Does/not/exist', handleFile)

function handleFile (error, file) {
  if (error) return console.error('Uhoh, there was an error', error)
  // в противном случае, продолжай и используй 'file' в своем коде
}
```
Первый аргумент будет `error` в первом соглашении, что не даст вам забыть обработать свои ошибки. Если бы это был второй аргумент, то вы могли бы написать код как `function handleFile (file) { }` и легко пропустить ошибку.

Линтеры кода также можно настроить, чтобы помочь вам не забывать обрабатывать ошибки обратного вызова. Самый простой в использовании это [стандарт](http://standardjs.com/). Все, что вам нужно сделать, это запустить `$ standard` в своей папке с кодом и он покажет вам каждый обратный вызов с необработанной ошибкой.

## Краткий итог

1. Не вкладывайте функции. Дайте им имена и разместите их на верхнем уровне программы
2. Используйте [поднятие функций(function hoisting)](https://gist.github.com/maxogden/4bed247d9852de93c94c) для своего преимущества в перемещении функций 'ниже сгиба'.
3. Обрабатывайте **каждую ошибку** в каждом ваше обратном вызове. Используйте линтер [стандарт](http://standardjs.com/) для помощи себе в этом.
4. Создавайте повторноиспользуемые функции и помещайте их в модули, чтобы уменьшить когнитивную нагрузку требуемую для понимания вашего кода. Разделяйте ваш код на маленькие кусочки, это так же поможем вам обрабатывать ошибки, писать тесты, вынудит вас создавать стабильный и задокументированный публичный API для вашего кода, и поможет с его рефакторингом.

Самый важный аспект ухода от ада обратных вызовов это **перемещение функций за пределы пути** так, что поток программы будет более понятен без первопроходцев, которым необходимо пробираться через все подробности функций, чтобы добраться до сути того, что программа пытается сделать.

Вы можете начать перемещать функции в конец файла, затем переместить их в другой файл который вы будете загружать как `require('./photo-helpers.js')` и затем переместить их в отдельный модуль как `require('image-resize')`.

Вот некоторые эмпирические правила при создании модуля:

- Начните с перемещения неоднократно использованного кода в функцию
- Когда ваша функция (или группа функци связанных одной темой) получится достаточно большой, переместите их в другой файл и вызывайте используя `module.exports`. Вы можете загружать его используя относительный вызов
- Если у вас есть некоторый код, который может быть использован в нескольких проектах, создайте ему собственный readme, тест и `package.json` и опубликуйте его на github и npm. У этого подхода так много преимуществ, что не будем перечислять их здесь.
- Хороший модуль небольшой и фокусируется на одной проблеме.
- В файле модуля не должно быть больше 150 строчек кода
- Модуль не должен иметь более одного уровня вложенности папок или JavaScript файлов. Если это произошло, то, вероятно, ваш модуль делает слишком много вещей
- Просите более опытных программистов показать вам примеры хороших модулей чтобы у вас сложилось хорошее представление о том как они должны выглядеть. Если понимание того, что происходит в модуле, занимает больше времени чем несколько минут, то это не очень хороший модуль.

## Что читать

Попробуйте прочесть мое [большое введение в обратные вызовы](https://github.com/maxogden/art-of-node#callbacks) или попробуйте пройти несколько уроков в [nodeschool](http://nodeschool.io/ru/).

Так же прочтите [карманный справочник browserify](https://github.com/substack/browserify-handbook) в каечтсве примера как писать модульный код.

## А что насчет промисов, генераторов, es6?

Прежде чем рассматривать более продвинутые решения, помните что обратные вызовы это фундаментальная часть JavaScript (поскольку они являются просто функциями) и вы должны научиться читать и писать их, прежде чем переходить к более продвинутым функциям языка, поскольку все они зависят от понимания обратных вызовов. Если вы не можете написать удобный для поддержки код обратных вызовов, то продолжайте работать над этим!

Если вы действительно хотите, чтобы ваш асинхронный код читаелся сверху вниз, то есть некоторые необычные вещи, которые вы можете попробовать. Обратите внимание что **они могут ввести производительность и/или возникнуть кроссплатформенные проблемы совместимости во время выполнения**, поэтому убедитесь, что вы все предусмотрели.

**Промисы** -- это путь написания асинхронного кода, который выглядит так, будто он исполняется сверху вниз, иобрабатывает больше типов ошибок из-за использования `try/catch` стиля обработки ошибок.

**Генераторы** позволяют вам 'приостановить' отдельную функцию без приостановки всей программы, который за счет чуть более сложного для понимания кода позволяет вашему асинхронному коду появится для выполнения в стиле сверху-вниз. Посмотрите [watt](https://github.com/mappum/watt) для примера такого подхода.

**Асинхронные функции** -- предложенная особенность ES7, которая далее обернет генераторы и промисы в высокоуровневый синтаксис. Посмотрите, если это звучит интересно для вас.

Лично я использую обратные вызовы в 90% случаях когда пишу асинхронный код и, когда все становится сложно, я произвожу в нечто вроде [run-parallel](https://github.com/feross/run-parallel) или [run-series](https://github.com/feross/run-series). Я не думаю, что обратные вызовы против промисов и против всего остального действительно имеют значение для меня, большим влиянием будет сохранение кода простым, не вложенным и разделенным на маленькие модули.

Независимо от метода, который вы выберите, всегда **обрабатывайте ошибки** и **делайте свой код простым**.

**Помните, только *вы* можете предотвратить ад обратных вызовов и лесные пожары.**
