*Перевод статьи Preethi Kasireddy:* https://medium.freecodecamp.com/lets-learn-javascript-closures-66feb44f6a44#.i3kdfkj4t

# Давайте выучим замыкания в Javascript

Замыкания являются одними из ключевых особенностей в JS, которые каждый уважающий себя программист должен знать наизусть.

В интернете есть множество объяснений тому "что" из себя представляют замыкания, но мало кто рассказывает "почему" они такие.

Я думаю, что понимание разработчиками принципов работы тех или иных особенностей языка даст им более глубокое знание инструментов, поэтому этот пост будет посвящён внутреннему устройству замыканий -- почему они работают и как они это делают.

Надеюсь после этой статьи вы будете использовать больше замыканий в своей повседневной разработке. Давайте начнем!

## Что такое замыкания?

Замыкания являются мощным свойством в JavaScript (и других языках программирования). Вот определение с [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures)

>Замыкания — это **функции, ссылающиеся на независимые (свободные) переменные**. Другими словами, функция, определённая в замыкании, **«запоминает» окружение, в котором она была создана**.

*Заметка: Свободные переменные -- это переменные, которые не объявлены в локальной области видимости, а передаются как параметр.*

Давайте посмотрим на несколько примеров:

### Пример 1

```javascript
function numberGenerator() {
  // Локальная "свободная" переменная которая доступна только в замыкании
  var num = 1;
  function checkNumber() {
    console.log(num);
  }
  num++;
  return checkNumber;
}

var number = numberGenerator();
number(); // 2
```

В примере выше функция `numberGenerator` создает локальную "свободную" переменную **num** (число) и **checkNumber** (функция, которая выводит число в консоль). Функция **checkNumber** не содержит в себе собственной локальной переменной, но она имеет доступ к переменным внутри другой функции, **numberGenerator** из-за замыкания.

### Пример 2

В этом примере мы покажем, что замыкания содержат в себе все локальные переменные, которые были объявлены внутри внешних замкнутых функций (enclosing function).

```javascript
function sayHello() {
  var say = function() { console.log(hello); }
  // Локальная переменная которая доступна только в замыкании
  var hello = 'Hello, world!';
  return say;
}
var sayHelloClosure = sayHello();
sayHelloClosure(); // ‘Hello, world!’
```
Обратите внимание как переменная **hello** определяется _после_ анонимной функции, но все еще может получить доступ к переменной **hello**. Это происходит из-за того, что переменная **hello** уже была определенна в области видимости(“scope”) во время создания, сделав ее доступной на тот момент, когда анонимная функция будет выполнена. (Не беспокойтесь, позже я объясню что такое "область видимости". А сейчас просто смиритесь с этим!:))

### Понимаем высокий уровень

Наши примеры показали нам "почему" замыкания находятся на высоком уровне. Главная мысль такая: *мы имеем доступ к переменным, которые были определены в замкнутых функциях и описывают их переменные как возвращенные*. Так же что-то происходит в фоновом режиме, что делает эти переменные доступными после замкнутых функций, которые определяют и возвращают их.

Чтобы понять как это работает, рассмотрим несколько связанных между собой идей, поэтому мы зайдем издалека и медленно вернемся обратно к замыканиям. Давайте начнем наш путь с общего *контекста* в котором выполняется функция и который известен как *контекст выполнения* (Execution context).

## Контекст выполнения

Контекст выполнения -- это абстрактное понятие которое используется в спецификации ECMAScript для оценки времени выполнения кода. Это может быть глобальный контекст (global context), в котором ваш код выполнится первым или когда поток выполнения переходит в тело функции.

![](https://cdn-images-1.medium.com/max/800/1*_LacLIeET7asTTIKpHCawA.png)

*В любой момент может выполняться только один контекст функции.* Вот почему Javascript является "однопоточным", т.к единовременно может выполняться только одна команда. Обычно браузеры поддерживают этот контекст с помощью "стека" (stack). Стек -- структура данных, выполняемая в обратном порядке (LIFO -- «последним пришёл — первым вышел»). Последнее, что вы добавили в стек, будет удалено первым из него. (Это происходит из-за того, что мы можем только добавить или удалить элементы из верхушки стека). Данный (текущий) или "выполняющийся" контекст исполнения -- это всегда верхний элемент стека. Он выскакивает вверх когда код полностью определен при выполнении, позволяя следующему верхнему элементу стека взять на себя контекст выполнения.

Кроме того, если контекст уже выполняется, это не означает, что ему нужно завершить свое выполнение, прежде чем другой контекст выполнения сможет начать работу. Бывают случаи, когда контекст приостанавливается и другой контекст выполнения начинает работу. Прерванный контекст может быть позже забран обратно наверх в том месте, где он был приостановлен. В любое время один контекст выполнения может быть заменен другим и этот новый контекст поместится в стек, став текущим контекстом выполнения.

![](https://cdn-images-1.medium.com/max/800/1*M8VqttSMghsxyXcBo2Zz1w.png)

Для наглядности запустите в консоли код, который вы видите ниже:

```javascript
var x = 10;
function foo(a) {
  var b = 20;

  function bar(c) {
    var d = 30;
    return boop(x + a + b + c + d);
  }

  function boop(e) {
    return e * -1;
  }

  return bar;
}

var moar = foo(5); // Замыкание
/*
  Функция ниже выполняет функцию bar, которая была возвращена в тот момент,
  когда мы выполнили функцию foo в строке выше. Функция bar
  вызывает boop, в этот момент bar получает приостановку и boop перемещается
  на вершину стека вызовов(call stack) (см. скриншот ниже)
*/
moar(15);
```
![](https://cdn-images-1.medium.com/max/800/1*YWiyU5u3ONPrszk8QvHaqw.png)

Затем, когда **boop** возвратится, он удалится из стека и **bar** продолжит работу:

![](https://cdn-images-1.medium.com/max/800/1*MMgltiRSX6zGyCPQTM7CjA.png)

Когда у нас есть целая куча контекстов исполнения, которые работают одна за другой, часто бывают приостановлены в середине выполнения и снова запущены, то нужно как-то отслеживать их состояние, чтобы мы могли управлять последовательностью выполнения этих контекстов. Согласно спецификации ECMAScript, каждый контекст выполнения имеет разное состояние компонентов, которые используются для отслеживания прогресса кода в каждом контексте которое он сделал. К ним относятся:

 - **Оценка состояния кода** -- любое состояние необходимо выполнить, приостановить и возобновить определение кода, связанного с этим контекстом выполнения
 - **Функция** -- объект функции, который оценивает контекст выполнения (или null если контекст был определен как *script* или *модуль*)
 - **Область** -- набор внутренних объектов глобального окружение ECMAScript, весь код ECMAScript, который находится в пределах этого глобального окружения и другие связанные с ним состояния и ресурсы
 - **Лексическое окружение** -- используется для разрешения ссылок идентификатора кода в данном контексте исполнения.
 - **Переменное окружение** -- Лексическое окружение чья Запись окружения (EnvironmentRecord) имеет связи созданные Заявленными Переменными(VariableStatements) в этом контексте выполнения.

Не волнуйтесь, если это звучит слишком сложно. Из всех  переменных, переменные Лексического окружения наиболее интересны для нас, ведь они явно указывают, что принимают *идентификатор ссылки* кода в этом контексте выполнения. Вы можете думать о "идентификаторах" как о переменных. Так как наша первоначальная цель состояла в том, чтобы выяснить, как это возможно, что мы получаем доступ к переменным даже после того, как функция (или "контекст") была возвращена, то мы должны копнуть еще глубже Лексическую Область Видимости.

***Заметка:*** С технической точки зрения, Окружение Переменных и Лексическая Область Видимости используются для реализации замыканий. Но для простоты, мы заменим его на "Окружение". Для детального объяснения разницы между Лексическим и Переменным окружением читайте статью Dr.Alex Rauschmayer’s [здесь](http://www.2ality.com/2011/04/ecmascript-5-spec-lexicalenvironment.html)

## Лексическая область видимости

Дадим определение: *Лексическое окружение -- специфичный тип, используемый для связи Идентификаторов с определенными переменными и функциями на основе лексической структуры вложенности кода ECMAScript. Лексическое окружение состоит из Записи окружения (Environment Record) и, возможно, нулевой ссылки на внешнее Лексическое окружение. Обычно Лексическое окружение связано с определенной синтаксической структурой, например FunctionDeclaration (Объявление функции), BlockStatement (оператор блока), Catch clause (условный оператор), TryStatement (Перехват ошибок) и новым Лексическим окружением которое создавалось каждый раз при вычислении кода. -- [ ECMAScript-262/6.0](http://www.ecma-international.org/ecma-262/6.0/#sec-lexical-environments)*

Давайте разберем это.

- ***"используемый для связи Идентификаторов"***: целью Лексического Окружения является управление данными (т.е. идентификаторами) в коде. Говоря иначе, это придает им смысл. Например, если бы у нас была такая строка в консоли *“console.log(x / 10)”*, то это была бы бессмысленная переменная (или идентификатор) *x* без чего-либо, что придавало бы переменной смысл. Лексическое окружение обеспечивает смысл (или "ассоциацию") через Запись Окружения. (смотрите ниже).

- ***Лексическое окружение состоит из Записи окружения***: Запись Окружения это причудливый способ сказать, что она хранит записи всех идентификаторов и связей, которые существуют в Лексической Области Видимости. Каждая Лексическая Область Видимости имеет свою собственную Запись Окружения.

- ***Лексическая структура вложенности***: это самый интересный момент, который говорит, что внутреннее окружение ссылается на внешнее окружение и это внешнее окружение может иметь своё собственное внешнее окружение. В результате окружение может быть внешним окружением для более чем одного внутреннего окружения. Глобальное окружение является единственным лексическим окружением, которое не имеет внешнего окружения. Это сложно описать словами, поэтому давайте использовать метафоры и представим лексическое окружение как слои лука: глобальная среда -- это внешний слой луковицы, каждый последующий слой находится ниже.

![](https://cdn-images-1.medium.com/max/1600/1*WIBH8HW9WzoKfBsQPGFHHg.png)

Так выглядит Окружение в псевдокоде:

```javascript
LexicalEnvironment = {
  EnvironmentRecord: {
  // Identifier bindings go here
  // Здесь идет привязка идентификатора
  },

  // Reference to the outer environment
  // Ссылка на внешнее окружение
  outer: < >
};
```

- ***Новое Лексическое окружение которое создавалось каждый раз при вычислении кода*** - каждый раз, когда внешние вложенные функции были вызваны, создается новое Лексическое окружение. Это важно -- мы вернемся к этому моменту в конце. (*Примечание: функции - не единственный способ создать Лексическое окружение. Другие содержат в себе оператор блока(block statement) или условный оператор(catch clause). Для простоты, я сосредоточусь на окружении созданной нами функции на протяжении всего поста*)

Каждый контекст исполнения имеет собственное Лексическое окружение. Это Лексическое окружение содержит переменные и связанные с ними значения, а так же имеет ссылку на него во внешнем окружении. Лексическое окружение может быть глобальным окружением, модульным окружением (которая содержит привязку для объявлений на высшем уровне объявлении Модуля) или окружением функций (окружение создается за счет вызова функции).

## Цепочки областей видимости

Исходя из приведенного выше определения, мы знаем, что окружение имеет доступ к окружению своего родителя, его родительское окружение имеет доступ к своему родительскому окружению и так далее. Этот набор идентификаторов, к которому каждое окружение имеет доступ называется "область видимости"(scope). Мы можем вложить их в иерархические цепочки окружения, известные как "цепочки областей видимости".

Давайте рассмотрим эту структуру вложенности:

```javascript
var x = 10;

function foo() {
  var y = 20; // свободная переменная
  function bar() {
    var z = 15; // свободная переменная
    return x + y + z;
  }
  return bar;
}
```

Как вы можете видеть, **bar** вложен в **foo**. Чтобы вы смогли всё это представить посмотрите на диаграмму ниже:

![](https://cdn-images-1.medium.com/max/1600/1*CwxZxltknV8DEEm_Y_ykfA.png)

Мы вернемся позже к этому примеру.

Эта цепочка области видимости (или цепочка окружения связанная с функцией) сохраняется в объекте функции в момент создания. Другими словами, она определяется статично по местоположению в исходном коде. (Это называют "лексической областью видимости").

Давайте быстренько разберем разницу между "динамической областью видимости" и "статической областью видимости, которая поможет нам разобраться, почему статическая область видимости (или лексическая область видимости) необходима для использования замыкания.

## Идем в обход: Динамическая область видимости против Статической области видимости

У динамических языков программирования существует "стековая архитектура" (stack-based implementations) -- локальные переменные и функции хранятся в стеке. Поэтому, во время выполнения стека, программа определяет какую переменную вы имеете в виду. С другой стороны, статическая область видимости -- это когда переменные ссылаются на контекст и фиксируются на *момент создания*. Другими словами, структура исходного кода программы определяет к каким переменным вы обращаетесь.

Вы могли задаваться вопросом, как  различаются Динамическая и Статическая область видимости. Вот два примера, которые помогут это проиллюстрировать:

### Пример 1

```javascript
var x = 10;

function foo() {
  var y = x + 5;
  return y;
}

function bar() {
  var x = 2;
  return foo();
}

function main() {
  foo(); // Static scope: 15; Dynamic scope: 15
  bar(); // Static scope: 15; Dynamic scope: 7
  return 0;
}
```

Как мы видим из примера выше, Статическая и Динамическая область видимости возвращают разные значения при вызове функции **bar**.

В статической области видимости возврат значения **bar** зависит от значения **x**. Это происходит из-за того, что статическая и лексическая структура исходного кода приводит **x** и к 10, и к 15.

Динамическая область видимости дает нам стек определенных переменных, которые отслеживаеются во время выполнения. Поэтому **x**, которую мы используем, зависит от того, что находится в её области видимости и как она была динамично определена во время выполнения. Выполнение функции **bar** выталкивает `x = 2` на верхушку стека, заставляя **foo** вернуть 7.

### Пример 2

```javascript
var myVar = 100;

function foo() {
  console.log(myVar);
}

foo(); // Static scope: 100; Dynamic scope: 100

(function () {
  var myVar = 50;
  foo(); // Static scope: 100; Dynamic scope: 50
})();

// Функция высшего порядка
(function (arg) {
  var myVar = 1500;
  arg();  // Static scope: 100; Dynamic scope: 1500
})(foo);
```

Аналогично и в Динамической области видимости. Переменная **myVar** решает какое использовать значение **myVar** в зависимости от того, где была вызвана функция. Статическая область видимости приводит **myVar** к переменной которая была сохранена в рамках двух немедленно вызываемых функций при их создании.

Как вы можете заметить, Динамическая область видимости часто создает некоторую двусмысленность. Она не дает точно понять какая свободная переменная будет передана.

## Замыкания

Вы можете подумать, что все, о чем мы говорим, совершенно не касается нашей темы, но на самом деле мы разобрали всё, что поможет нам понять замыкания:

> *Каждая функция имеет контекст выполнения, который состоит из окружения и которое передает смысл в переменные этой функции и ссылку на окружение своего родителя. Эта ссылка делает все переменные в родительской области доступными для всех внутренних функций, независимо от того, вызывается ли внутренняя функция(или функции) вне или внутри области видимости, в которой они были созданы.*
>
> *Кажется как-будто функция “запоминает” это окружение, поскольку функция буквально имеет ссылку к области видимости (и переменным, определенным в этой среде)!*

Возвратимся к примеру вложенной структуры:

```javascript
var x = 10;

function foo() {
  var y = 20; // свободная переменная
  function bar() {
    var z = 15; // свободная переменная
    return x + y + z;
  }
  return bar;
}

var test = foo();

test(); // 45
```

Основываясь на нашем понимании того, как работает окружение, мы можем сказать, что определение окружения для вышеупомянутого примера выглядит примерно так (примечание: это псевдокод):

```javascript
GlobalEnvironment = {
  EnvironmentRecord: {
    // встроенные идентификаторы
    Array: '<func>',
    Object: '<func>',
    // и т.д.

    // пользовательские идентификаторы
    x: 10
  },
  outer: null
};

fooEnvironment = {
  EnvironmentRecord: {
    y: 20,
    bar: '<func>'
  }
  outer: GlobalEnvironment
};

barEnvironment = {
  EnvironmentRecord: {
    z: 15
  }
  outer: fooEnvironment
};
```
Когда мы вызываем функцию **test**, мы получаем 45, которая возращает значение из вызова функции **bar** (потому что **foo** возвращает **bar**). **bar** имеет доступ к свободной переменной **y** даже после того, как функция **foo** вернется, потому что **bar** имеет ссылку на **y** через его внешнее окружение, которое является окружением **foo**! **bar** так же имеет доступ к глобальной переменной **x** потому что у окружения **foo** есть доступ к глобальному окружению. Это называют *"поиск цепочки области видимости"*.

Подведем итог обсуждения Динамической области видимости против Статической: для замыканий, которые будут выполняться, нельзя использовать динамичеcкую область с помощью динамического стека. Это сохранит наши переменные. Причина этого кроется в том, что когда функция возвращается, переменные будут удалены из стека и больше не будут доступны, что противоречит нашему определению замыкания. Это происходит из-за того, что замкнутость данных в родительском контексте сохраняется в том, что называется "кучей" и это позволяет сохранять данные после вызова функции, делая их возможными для возврата (т.е. даже после того, как контекст выполнения извлекается из стека выполнения вызова).

Теперь, когда мы понимаем внутренности на абстрактном уровне, давайте рассмотрим еще пару примеров:

### Пример 1

Вот типичное заблуждение: в цикле for мы пробуем связать переменную счетчика с какой-либо функцией.

```javascript
var result = [];

for (var i = 0; i < 5; i++) {
  result[i] = function () {
    console.log(i);
  };
}

result[0](); // 5, ожидалось 0
result[1](); // 5, ожидалось 1
result[2](); // 5, ожидалось 2
result[3](); // 5, ожидалось 3
result[4](); // 5, ожидалось 4
```

На основе всего, что мы разобрали ранее, мы можем с легкостью найти ошибку здесь! Абстрактно говоря, вот так выглядит окружение, во время выхода из цикла for:

```javascript
environment: {
  EnvironmentRecord: {
    result: [...],
    i: 5
  },
  outer: null,
}
```
Было бы неверно предполагать, что область видимости отличается для всех пяти функций в результирующем массиве. Вместо того, что происходит по факту, окружение (или контекст/область видимости) является тем же самым для всех пяти функций в пределах результирующего массива. Поэтому, каждый раз, когда переменная **i** увеличивается, обновляется область видимости, а она является общей для всех функций. Из-за этого любая из 5 функций, пытающихся получить доступ к **i**, возвращает 5. (i равна 5 когда цикл завершается).

У нас есть только один способ исправить это -- создать дополнительный вызываемый контекст для каждой функции, чтобы у них появился свой собственный контекст/область видимости.

```javascript
var result = [];

for (var i = 0; i < 5; i++) {
  result[i] = (function inner(x) {
    // дополнительный вызываемый контекст
    return function() {
      console.log(x);
    }
  })(i);
}

result[0](); // 0, ожидалось 0
result[1](); // 1, ожидалось 1
result[2](); // 2, ожидалось 2
result[3](); // 3, ожидалось 3
result[4](); // 4, ожидалось 4
```

Да! Мы пофиксили это :)

Есть еще одно решение, в котором мы используем **let** вместо **var**, так **let** находится в операторе блока и поэтому новая привязка идентификатора замыкания создается для каждой итерации в цикле for.

```javascript
var result = [];

for (let i = 0; i < 5; i++) {
  result[i] = function () {
    console.log(i);
  };
}

result[0](); // 0, ожидалось 0
result[1](); // 1, ожидалось 1
result[2](); // 2, ожидалось 2
result[3](); // 3, ожидалось 3
result[4](); // 4, ожидалось 4

```

Tada! :)

### Пример 2

В этом примере мы покажем как каждый *вызов* в функции создает новое отдельное замыкание:

```javascript
function iCantThinkOfAName(num, obj) {
  // Это массив переменных, вместе с 2 параметрами, передаваемых
  // "захваченными" в замкнутую функцию 'doSomething'
  var array = [1, 2, 3];
  function doSomething(i) {
    num += i;
    array.push(num);
    console.log('num: ' + num);
    console.log('array: ' + array);
    console.log('obj.value: ' + obj.value);
  }

  return doSomething;
}

var referenceObject = { value: 10 };
var foo = iCantThinkOfAName(2, referenceObject); // замыкание #1
var bar = iCantThinkOfAName(6, referenceObject); // замыкание #2

foo(2);
/*
  num: 4
  array: 1,2,3,4
  obj.value: 10
*/

bar(2);
/*
  num: 8
  array: 1,2,3,8
  obj.value: 10
*/

referenceObject.value++;

foo(4);
/*
  num: 8
  array: 1,2,3,4,8
  obj.value: 11
*/

bar(4);
/*
  num: 12
  array: 1,2,3,8,12
  obj.value: 11
*/
```

В этом примере мы видим что каждый вызов в функции **iCantThinkOfAName** создает новое замыкание, а именно **foo** и **bar**.
Последующие вызовы каждой замкнутой функции обновляют замкнутые переменные в пределах самого замыкания, демонстрируя, что переменные в *каждом* замыкании используются функции **iCantThinkOfAName’s doSomething** после того, как вернулась **iCantThinkOfAName**.

### Пример 3

```javascript
function mysteriousCalculator(a, b) {
	var mysteriousVariable = 3;
	return {
		add: function() {
			var result = a + b + mysteriousVariable;
			return toFixedTwoPlaces(result);
		},

		subtract: function() {
			var result = a - b - mysteriousVariable;
			return toFixedTwoPlaces(result);
		}
	}
}

function toFixedTwoPlaces(value) {
	return value.toFixed(2);
}

var myCalculator = mysteriousCalculator(10.01, 2.01);
myCalculator.add() // 15.02
myCalculator.subtract() // 5.00
```

Мы виидим, что **mysteriousCalculator** находится в глобальной области и возвращает две функции. Говоря иначе, окружение для кода выше будет выглядеть так:

```javascript

GlobalEnvironment = {
  EnvironmentRecord: {
    // встроенные идентификаторы
    Array: '<func>',
    Object: '<func>',
    // и т.д.

    // пользовательские идентификаторы
    mysteriousCalculator: '<func>',
    toFixedTwoPlaces: '<func>',
  },
  outer: null,
};

mysteriousCalculatorEnvironment = {
  EnvironmentRecord: {
    a: 10.01,
    b: 2.01,  
    mysteriousVariable: 3,
  }
  outer: GlobalEnvironment,
};

addEnvironment = {
  EnvironmentRecord: {
    result: 15.02
  }
  outer: mysteriousCalculatorEnvironment,
};

subtractEnvironment = {
  EnvironmentRecord: {
    result: 5.00
  }
  outer: mysteriousCalculatorEnvironment,
};
```

Это происходит из-за того, что наши функции **add** и **substract** ссылаются на среду **mysteriousCalculator** и они в состоянии использовать переменные этой среды для расчета результата.

### Пример 4

Последний пример продемонстрирует важность использования замыканий: для поддержания собственной ссылки на переменную во внешней области видимости.

```javascript
function secretPassword() {
  var password = 'xh38sk';
  return {
    guessPassword: function(guess) {
      if (guess === password) {
        return true;
      } else {
        return false;
      }
    }
  }
}

var passwordGame = secretPassword();
passwordGame.guessPassword('heyisthisit?'); // false
passwordGame.guessPassword('xh38sk'); // true
```

Это очень сильная техника -- это дает замыкающей функции **guessPassword** исключительный доступ к переменной **password**, делая невозможным доступ к **password** снаружи.

## Tl;dr

- Контекст выполнения -- это абстрактный контекст использовавшийся в спецификации ECMAScript для отслеживания оценки времени выполнения кода. В любой момент времени может быть только один контекст выполнения, который выполняет код.
- Каждый контекст исполнения имеет Лексическое окружение. Оно содержит связи идентификаторов (то есть переменные и их значения, и имеет ссылку на него во внешнем окружении.
- Набор идентификаторов, к которым у каждого окружения есть доступ, называют "область видимости". Мы можем вложить эти области в иерархическую цепь окружения, известной как “цепь области видимости”.
- Каждая функция имеет контекст выполнения, которая включает в себя Лексическое окружение. Это дает переменным значение в пределах этой функции и ссылку на родительское окружение. И это означает, что функции "запоминают" окружение (или область видимости) потому, что они буквально ссылаются на это окружение. Это и есть замыкание.
- Замыкания создаются каждый раз при вызове закрытой внешней функции. Другими словами, внутренняя функция не будет возвращена для замыкания в котором была создана.
- Область видимости замыканий в JavaScript лексическая, её смысл определяется статично в зависимости от нахождения в исходном коде.
- Есть множество практических случаев для использования замыканий. Один из важных случаев использования -- это сохранение приватных ссылок к переменным во внешней среде.

## Завершающая (замыкающая) ремарка

Я надеюсь этот пост был полезным и дал вам предстовление о том, как замыкания реализованы в JavaScript. Как вы видите, понимание внутреннего устройства замыканий и как они работают делают их поиск проще. Теперь у вас будет меньше головной боли при отладке!

## Дополнительная литература

Для краткости я опустила несколько тем, которые могут быть интересны для некоторых читателей. Вот несколько ссылок, которыми я хотела бы поделиться:

- **Какие среды переменных бывают в контексте выполнения?** Dr. Axel Rauschmayer сделал феноменальную объясняющую работу по этой теме, и я просто оставлю ссылку на его пост:
http://www.2ality.com/2011/04/ecmascript-5-spec-lexicalenvironment.html
- **Что является различными типами записи окружения?** Читайте спецификацию здесь: http://www.ecma-international.org/ecma-262/6.0/#sec-environment-records
- **Отличная статья на MDN про замыкания** https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures
- Есть что-то еще? Предлагайте!
