*Перевод статьи Preethi Kasireddy:* https://medium.freecodecamp.com/lets-learn-javascript-closures-66feb44f6a44#.i3kdfkj4t

# Давайте выучим замыкания в Javascript

Замыкания являются фундаментальным понятием в JS, которое каждый серьезный программист должен знать наизусть.
В интернете много материала на тему замыканий, но ни один из них не погружен в тему достаточно глубоко.

В интернете есть множество объяснений "что" такое замыкания, но мало кто глубоко погружается в вопрос "почему" они работают.

Я считаю, что имея представление о том как работают замыкания на глубоком уровне, поможет разработчикам сильно понять свои инструменты для работы, поэтому этот пост будет посвящен гайкам и болтам -- как и почему работают замыкания и как они это делают.

Надеюсь после этой статьи вы будете использовать больше замыканий в своей повседневной разработке. Давайте начнем!

## Что такое замыкания?

Замыкания являются мощным свойством в JavaScript (и других языках программирования). Вот определение с [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures)

>Замыкания — это **функции, ссылающиеся на независимые (свободные) переменные**. Другими словами, функция, определённая в замыкании, **«запоминает» окружение, в котором она была создана**.

*Заметка: Свободные переменные -- это переменные, которые не объявлены в локальной области видимости, а передаются как параметр.*

Давайте посмотрим на несколько примеров:

### Пример 1

```javascript
function numberGenerator() {
  // Локальная "свободная" переменная которая доступна только в замыкании
  var num = 1;
  function checkNumber() {
    console.log(num);
  }
  num++;
  return checkNumber;
}

var number = numberGenerator();
number(); // 2
```

В примере выше, функция numberGenerator создает локальную "свободную" переменную **num** (число) и **checkNumber** (функция, которая выводит число в консоль). Функция **checkNumber** не содержит в себе какой-нибудь собственной локальной переменной -- однако, она имеет доступ к переменным внутри другой функции, **numberGenerator**, из-за замыкания.

### Пример 2

В этом примере мы покажем, что замыкания содержат в себе все локальные переменные, которые были объявлены внутри внешних вложенных функций (enclosing function).

```javascript
function sayHello() {
  var say = function() { console.log(hello); }
  // Локальная переменная которая доступна только в замыкании
  var hello = 'Hello, world!';
  return say;
}
var sayHelloClosure = sayHello();
sayHelloClosure(); // ‘Hello, world!’
```
Обратите внимание как переменная **hello** определяется после анонимной функции, но все еще может получить доступ к переменной **hello**. Это происходит потому, что переменная **hello** уже была определенна в области видимости функции (“scope”) в момент создания, сделав ее доступной, когда анонимная функция будет выполнена. (Не беспокойтесь, позже я объясню что такое "область видимости" ("scope"). А сейчас просто смиритесь с этим!:))

### Понимание высокого уровня

Эти примеры показывают "почему" замыкания находятся на высоком уровне. Главная мысль такая: *мы имеем доступ к переменным, которые определены во вложенной функции(функциях), которые определяют эти переменные как возвращенные*. Очевидно, что что-то происходит в фоновом режиме, что позволяет этим переменным быть доступными после вложенных функций, которые определяют и возвращают их.

Чтобы понять как это возможно, мы должны оставновиться на малосвязанных понятиях -- стартем с 3000 шагов вверх и медленно пройдем свой путь вниз обратно к замыканиям. Давайте начнем свой путь с общего *контекста* к котором выполянется функция, который так же известен как *контекст выполнения* (Execution context).

## Контекст выполнения

Контекст выполнения -- это абстрактное понятие которое используется в спецификации ECMAScript для оценки времени выполнения кода. Это может быть глоабльный контекст (global context), в котором ваш код будет исполнен первым или когда поток выполнения переходит в тело функции.

![](https://cdn-images-1.medium.com/max/800/1*_LacLIeET7asTTIKpHCawA.png)

*В любой момент времени может быть осуществлен только один контекст выполнения функции.* Вот почему Javascript является "однопоточным", т.к может быть выполнена только одна команда одновременно. Обычно браузеры поддерживают этот контекст выполнения с помощью "стека" (stack). Стек -- структуры данных обслуживаемых в обратном порядке (примеч.пер.: LIFO -- «последним пришёл — первым вышел»), последнее, что вы добавили в стек, будет удалено первым из него. (Это происходит из-за того, что мы можем только вставить или удалить элементы из верхушки стека). Данный (текущий) или "выполняющийся" контекст исполнения -- это всегда верхний элемент стека. Он выскакивает вверх когда код в рабочем контексте выполнения полностью определен, позволяя следующему верхнему элементу взять на себя контекст выполнения.

Кроме этого, только потому, что контекст исполнения выполняется, это вовсе не означает, что он должен завершить работу, прежде чем другой контекст выполнения сможет начать работать. Бывают случаи, когда контекст выполнения приостанавливается и другой контекст выполнения становится работающим контекстом выполнения. Прерванный контекст выполнения может быть позже забран обратно наверх в том месте, где было сделано прерывание выполнения. В любое время один контекст выполнения может быть заменен другим, новый контекст выполнения создается и помещается в стек, став текущим контекстом выполнения.

![](https://cdn-images-1.medium.com/max/800/1*M8VqttSMghsxyXcBo2Zz1w.png)

Для наглядного примера запустите в консоли код, который вы видите ниже:

```javascript
var x = 10;
function foo(a) {
  var b = 20;

  function bar(c) {
    var d = 30;
    return boop(x + a + b + c + d);
  }

  function boop(e) {
    return e * -1;
  }

  return bar;
}

var moar = foo(5); // Замыкание
/*
  Функция ниже выполняет функцию bar, которая была возвращена в тот момент,
  когда мы выполнили функцию foo в строке выше. Функция bar
  вызывает boop, в этот момент bar получает приостановку и boop перемещается
  на вершину стека вызовов(call stack) (см. скриншот ниже)
*/
moar(15);
```
![](https://cdn-images-1.medium.com/max/800/1*YWiyU5u3ONPrszk8QvHaqw.png)

Затем, когда **boop** будет возвращен, он удаляется из стека и **bar** продолжает работу:

![](https://cdn-images-1.medium.com/max/800/1*MMgltiRSX6zGyCPQTM7CjA.png)

Когда у нас есть куча контекстов исполнения, работающих одна за другой — часто приостановленных в середине и потом возобновленных, то нам нужно как-то отслеживать их состояние, чтобы мы могли управлять последовательностью и выполнением в этих контекстах. И на самом деле, согласно спецификации ECMAScript, каждый контекст выполнения имеет разное состояние компонентов, которые используются для отслеживания прогресса кода в каждом контексте которое он сделал. К ним относятся:

 - **Оценка состояния кода** -- любое состояние необходимо выполнить, приостановить, и возобновить определение кода, связанного с этим контекстом исполнения
 - **Функция** -- объект функции, который оценивает контекст выполнения (или null если контекст выполнения был определен как *script* или *модуль*)
 - **Область** -- набор внутренних объектов, глобальное окружение ECMAScript, весь код ECMAScript, который загружен в пределах этого глобального окружения, и другие связанные состояния и ресурсы
 - **Лексическое окружение** -- используется для разрешения ссылок идентификатора, для создания кода в данном контексте исполнения.
 - **Переменное окружение** -- Лексическое окружение чья Запись окружения (EnvironmentRecord) имеет связи созданные Заявленными Переменными(VariableStatements) в этом контексте выполнения.

Если это звучит слишком запутанно для вас, не волнуйтесь. Из всех этих переменных, переменные Лексического окружения являются наиболее интересными для нас, ведь они явно указывают, что они принимают *идентификатор ссылки* кода в этом контексте выполнения. Вы можете думать о "идентификаторах" в качестве переменных. Так как наша первоначальная цель состояла в том, чтобы выяснить, как это возможно для нас, что мы волшебным образом получаем доступ к переменным, даже после того, как функция (или "контекст") была возвращена, Лексическая Область Видимости выглядит как что-то, что мы должны копнуть еще глубже.

***Заметка:*** Технически, и Окружение Переменных и Лексическая Область Видимости используются для реализации замыканий. Но для простоты, мы обобщим его на "Окружение". Для детального объяснения разницы между Лексическим и Переменным окружением читайте статью Dr.Alex Rauschmayer’s [здесь](http://www.2ality.com/2011/04/ecmascript-5-spec-lexicalenvironment.html)

## Лексическая область видимости

Дадим определение: *Лексическое окружение -- это тип спецификации используемый для определения ассоциации идентификаторов переменных и функций на основе лексической структуры вложенности в ECMAScript коде. Лексическое окружение состоит из Записи окружения и нулевой ссылки на внешнюю Лексическую среду. Обычно Лексическое окружение связано с какой-либо специфической синтаксической структурой кода ECMAScript, такой как FunctionDeclaration, BlockStatement или Catch clause в TryStatement и нового Лексического окружения создающегося каждый раз, когда такой код вычисляется. -- [ ECMAScript-262/6.0](http://www.ecma-international.org/ecma-262/6.0/#sec-lexical-environments)*

Давайте разберем это.

- ***"используется для определения ассоциации идентификаторов"***: целью Лексического Окружения является управлением данными (т.е. идентификаторами) в коде. Другими словами, это придает идентификаторам смысл. Например, если бы у нас была такая строка в консоли *“console.log(x / 10)”*, то это была бы бессмысленная переменная (или идентификатор) *x* без чего-либо, что придавало бы этой переменной смысл. Лексическое окружение обеспечивает этот смысл (или "ассоциацию") через его Запись Окружения. (смотрите ниже).

- ***Лексическое окружение состоит из Записи окружения*** - Запись Окружения это причудливый способ сказать, что она хранит записи всех идентификаторов и их привязки(связи), которые существуют в Лексической Области Видимости. Каждая Лексическая Область Видимости имеет свою собственную Запись Окружения.

- ***Лексическая структура вложенности*** - это самый интересный момент, который говорит, что внутреннее окружение ссылается на внешнее окружение и что это внешнее окружение может иметь своё собственное внешнее окружение. В результате окружение может быть внешним окружением для более чем одной внутреннего окружения. Глобальное окружение является единственным лексическим окружением, которое не имеет внешнее окружение. Это сложно описать словами, поэтому давайте использовать метафоры и думать о лексическом окружении как о слоях лука: глобальная среда -- это внешний слой луковицы; каждый последующий слой находится ниже.

![](https://cdn-images-1.medium.com/max/1600/1*WIBH8HW9WzoKfBsQPGFHHg.png)

Абстрактно говоря, так выглядит Окружение в псевдокоде:

```javascript
LexicalEnvironment = {
  EnvironmentRecord: {
  // Identifier bindings go here
  // Здесь идет привязка идентификатора
  },

  // Reference to the outer environment
  // Ссылка на внешнее окружение
  outer: < >
};
```

- ***Новое Лексическое окружение создается каждый раз, когда такой код вычисляется*** - каждый раз, когда внешние вложенные функции вызываются, создается новое Лексическое окружение. Это важно -- мы будем возвращаться к этому моменту в конце. (*Примечание: функции - не единственный способ создать Лексическое окружение. Другие содержат в себе объявленные блоки или отлавливают условия. Для простоты, я сосредоточусь на окружении созданной функции на протяжении всего этого поста*)

Коротко говоря, каждый контекст исполнения имеет собственное Лексическое окружение. Эта Лексическое окружение содержит переменные и связанные с ними значения, а так же имеет ссылку на него во внешнем окружении. Лексическое окружение может быть глоабльным окружением, модульным окружением (которая содержит привязку для объявлений на высшем уровне объявлении Модуля) или окружение функций (окружение создается за счет вызова функции).

## Цепочки областей видимости

Исходя из приведенного выше определения, мы знаем, что окружение имеет доступ к окружению своего родителя, и ее родительское окружение имеет доступ к своему родительскому окружению и так далее. Этот набор идентификаторов, к которому каждое окружение имеет доступ и называется "область видимости"(scope). Мы можем вложить их в иерархическую цепочку окружения, известных как "цепочки областей видимости".

Давайте рассмотрим на примере эту структуру вложенности:

```javascript
var x = 10;

function foo() {
  var y = 20; // свободная переменная
  function bar() {
    var z = 15; // свободная переменная
    return x + y + z;
  }
  return bar;
}
```

Как вы можете видеть, **bar** вложен в **foo**. Чтобы помочь вам это все визуализировать, посмотрите на диаграмму ниже:

![](https://cdn-images-1.medium.com/max/1600/1*CwxZxltknV8DEEm_Y_ykfA.png)

Мы вернеся позже к этому примеру.

Эта цепочка области видимости, или цепочка окружения связанная с функцией, сохраняется в объекте функции в момент ее создания. Другими словами, она определяется статично по местоположению в исходном коде. (Это так же называют "лексической областью видимости").

Давайте быстренько разберем далее разницу между "динамической областью видимости" и "статической областью видимости, которая поможет понять разобраться, почему статическая область видимости (или лексическая область видимости) необходима для того, чтобы использовать замыкания.

## Обходной пункт: Динамическая область видимости против Статической области видимости

Динамические языки имеют "стек на основе реализации", это означает, что локальныет переменные и функции хранятся в стеке. Поэтому во время выполнения стека программа определяет, какую переменную вы имеете в виду. С другой стороны, статическая область видимости - это когда переменные ссылаются на контекст и фиксируются на *момент создания*. Другими словами, структура исходного кода программы определяет к каким переменным вы обращаетесь.

При этом Вы могли бы задаваться вопросом, как Динамическая и Статическая область видимости различаются. Вот два примера, которые помогут это проиллюстрировать:

### Пример 1

```javascript
var x = 10;

function foo() {
  var y = x + 5;
  return y;
}

function bar() {
  var x = 2;
  return foo();
}

function main() {
  foo(); // Static scope: 15; Dynamic scope: 15
  bar(); // Static scope: 15; Dynamic scope: 7
  return 0;
}
```

Как мы видим из примера выше, Статическая и Динамическая область видимости возвращают разные значения при вызове функции **bar**.

В статической области видимости возврат значения **bar** зависит от значения **x**. Это происходит из-за того,что статическая и лексическая структура исходного кода приводит **x** и к 10, и к 15.

Динамическая область видимости, с другой стороны, дает нам стек определений переменных отслеживаемых во время выполнения -- таких, что **x**, которую мы используем, зависит от того,что находится в области видимости и как была динамично определена во время выполнения. Выполнение функции **bar** выталкивает x = 2 на верхушку стека, заставляя **foo** вернуть 7.

### Пример 2

```javascript
var myVar = 100;

function foo() {
  console.log(myVar);
}

foo(); // Static scope: 100; Dynamic scope: 100

(function () {
  var myVar = 50;
  foo(); // Static scope: 100; Dynamic scope: 50
})();

// Higher-order function
(function (arg) {
  var myVar = 1500;
  arg();  // Static scope: 100; Dynamic scope: 1500
})(foo);
```

Аналогично в Динамической области видимости из примера выше переменная **myVar** будет решать какое использовать значение **myVar** в зависимости от того, где была вызвана функция. Статическая область видимости, с другой стороны, приводит **myVar** к переменной которая была сохранена в рамках двух немедленно вызываемых функций при их создании.

Как вы можете заметить, Динамическая область видимости часто првиодит к некоторой двусмысленности. Это не дает точно понять какая свободная переменная будет передана.

## Замыкания

Вы можете подумать, что все, о чем мы говорили, совершенно не касается нашей темы, но на самом деле мы разобрали всё, что поможет нам понять замыкания:

> *Каждая функция имеет контекст выполнения, которая состоит из среды, которая передает смысл в переменные в этой функции и ссылку на окружение своего родителя. Ссылка на окружение родителей делает все переменные в родительской области доступными для всех внутренних функций, независимо от того, вызывается ли внутренняя функция(функции) вне или внутри области видимости, в которой они были созданы.*
>
> *Так, кажется, как будто функция “помнит” это окружение, поскольку функция буквально имеет ссылку к этой области вдимости (и переменным, определенным в этой среде)!*

Возвращаясь к примеру вложенной структуры:

```javascript
var x = 10;

function foo() {
  var y = 20; // free variable
  function bar() {
    var z = 15; // free variable
    return x + y + z;
  }
  return bar;
}

var test = foo();

test(); // 45
```

Основываясь на нашем понимании того, как работает окружение, мы можем сказать, что определение окружения для вышеупомянутого примера выглядит примерно так (примечание, это - псевдокод):

```javascript
GlobalEnvironment = {
  EnvironmentRecord: {
    // built-in identifiers
    Array: '<func>',
    Object: '<func>',
    // etc..

    // custom identifiers
    x: 10
  },
  outer: null
};

fooEnvironment = {
  EnvironmentRecord: {
    y: 20,
    bar: '<func>'
  }
  outer: GlobalEnvironment
};

barEnvironment = {
  EnvironmentRecord: {
    z: 15
  }
  outer: fooEnvironment
};
```
Когда мы вызываем функцию **test**, мы получаем 45, которое является возращаемым значением от вызова функции **bar** (потому что **foo** возвращает **bar**). **bar** имеет доступ к свободной переменной **y** даже после того, как функция **foo** вернется, потому что **bar** имеет ссылку на **y** через его внешнее окружение, которое является окружением **foo**! **bar** так же имеет доступ к глобальной переменной **x** потому что у окружения **foo** есть доступ к глобальному окружению. Это называют *"поиск цепочки области видимости"*.

Возвращаясь к нашему осбуждению Динамической области видимости против Статической: для замыканий, которые будут выполнены, мы не можем использовать динамичеcкую область с помощью динамического стека чтобы сохранить наши переменные. Причина в том, что когда функция возвращается, переменные будут удалены из стека и больше не будут доступны, что противоречит нашему определению замыкания. Дело в том, что замкнутость данных в родительском контексте сохраняется в том, что называется "кучей", что позволяет сохранять данные после вызова функции, делая их возвращаемыми (т.е. даже после того, как контекст выполнения извлекается из стека выполнения вызова).

Все понятно? Хорошо. Теперь, когда мы понимаем внутренности на абстрактном уровне, давайте рассмотрим еще пару примеров:

### Пример 1

Один канонический пример/заблуждение, когда в цикле for и мы пробуем связать переменную счетчика в цикле for с какой-то функцией в цикле for.

```javascript
var result = [];

for (var i = 0; i < 5; i++) {
  result[i] = function () {
    console.log(i);
  };
}

result[0](); // 5, ожидалось 0
result[1](); // 5, ожидалось 1
result[2](); // 5, ожидалось 2
result[3](); // 5, ожидалось 3
result[4](); // 5, ожидалось 4
```

Возвращаясь к тому, что мы изучили ранее, становиться очень легко найти ошибку здесь! Абстрактно говоря, вот как выглядит окружение, во время выхода из цикла for:

```javascript
environment: {
  EnvironmentRecord: {
    result: [...],
    i: 5
  },
  outer: null,
}
```
Здесь было бы неправильно предполагать, что область видимости отличается для всех пяти функций в массиве результата. Вместо того, что фактически происходит, окружение (или контекст/область видимости) является тем же самым для всех пяти функций в пределах результирующего массива. Поэтому, каждый раз, когда переменная **i** увеличивается, это обновляет область видимости -- которая является общей для всех функций. Вот почему любая из 5 функций, пытающихся получить доступ к **i** возвращает 5. (i равна 5 когда цикл завершается).

Есть только один способ исправить это -- создать дополнительный вызываемый контекст для каждой функции, чтобы у каждой появилися свой собственный контекст/область видимости.

```javascript
var result = [];

for (var i = 0; i < 5; i++) {
  result[i] = (function inner(x) {
    // дополнительный вызываемый контекст
    return function() {
      console.log(x);
    }
  })(i);
}

result[0](); // 0, ожидалось 0
result[1](); // 1, ожидалось 1
result[2](); // 2, ожидалось 2
result[3](); // 3, ожидалось 3
result[4](); // 4, ожидалось 4
```

Да! Мы пофиксили это :)

Есть еще один подход? который заключается в том, что мы используем **let** вместо **var**, так **let** в блоке-области и поэтому новая привязка идентификатора замыкания создается для каждой итерации в цикле for.

```javascript
var result = [];

for (let i = 0; i < 5; i++) {
  result[i] = function () {
    console.log(i);
  };
}

result[0](); // 0, ожидалось 0
result[1](); // 1, ожидалось 1
result[2](); // 2, ожидалось 2
result[3](); // 3, ожидалось 3
result[4](); // 4, ожидалось 4

```

Tada! :)

### Пример 2

В этом примере мы покажем как каждый *call* в функции создает новое отдельное замыкание:

```javascript
function iCantThinkOfAName(num, obj) {
  // Это массив переменных, вместе с 2 параметрами, передаваемыми
  // "захваченными" во вложенную функцию 'doSomething'
  var array = [1, 2, 3];
  function doSomething(i) {
    num += i;
    array.push(num);
    console.log('num: ' + num);
    console.log('array: ' + array);
    console.log('obj.value: ' + obj.value);
  }

  return doSomething;
}

var referenceObject = { value: 10 };
var foo = iCantThinkOfAName(2, referenceObject); // замыкание #1
var bar = iCantThinkOfAName(6, referenceObject); // замыкание #2

foo(2);
/*
  num: 4
  array: 1,2,3,4
  obj.value: 10
*/

bar(2);
/*
  num: 8
  array: 1,2,3,8
  obj.value: 10
*/

referenceObject.value++;

foo(4);
/*
  num: 8
  array: 1,2,3,4,8
  obj.value: 11
*/

bar(4);
/*
  num: 12
  array: 1,2,3,8,12
  obj.value: 11
*/
```

В этом примере мы видим как, каждый раз, вызов в функции **iCantThinkOfAName** создает новое замыкание, а именно **foo** и **bar**.
Последующие вызовы каждой замкнутой функции обновляют закрытие переменных в пределах самого замыкания, демонстрирую, что перемнные в *каждом* замыкании используются **iCantThinkOfAName’s doSomething** функциями долго после того, как вернулась **iCantThinkOfAName**.

### Пример 3

```javascript
function mysteriousCalculator(a, b) {
	var mysteriousVariable = 3;
	return {
		add: function() {
			var result = a + b + mysteriousVariable;
			return toFixedTwoPlaces(result);
		},

		subtract: function() {
			var result = a - b - mysteriousVariable;
			return toFixedTwoPlaces(result);
		}
	}
}

function toFixedTwoPlaces(value) {
	return value.toFixed(2);
}

var myCalculator = mysteriousCalculator(10.01, 2.01);
myCalculator.add() // 15.02
myCalculator.subtract() // 5.00
```

Вы можете видеть что **mysteriousCalculator** в глобальной области и возращает две функции. Абстрактно говоря, среда для кода выше будет выглядеть так:

```javascript

GlobalEnvironment = {
  EnvironmentRecord: {
    // built-in identifiers
    Array: '<func>',
    Object: '<func>',
    // etc...

    // custom identifiers
    mysteriousCalculator: '<func>',
    toFixedTwoPlaces: '<func>',
  },
  outer: null,
};

mysteriousCalculatorEnvironment = {
  EnvironmentRecord: {
    a: 10.01,
    b: 2.01,  
    mysteriousVariable: 3,
  }
  outer: GlobalEnvironment,
};

addEnvironment = {
  EnvironmentRecord: {
    result: 15.02
  }
  outer: mysteriousCalculatorEnvironment,
};

subtractEnvironment = {
  EnvironmentRecord: {
    result: 5.00
  }
  outer: mysteriousCalculatorEnvironment,
};
```

Потому что наши **add** и **substract** функции ссылаются на среду **mysteriousCalculator**, а они в состоянии использовать переменные той среды для расчета результата.

### Пример 4

Последний пример продемонстрирует важность использования замыканий: для поддержания собственной ссылки на переменную во внешней области видимости.

```javascript
function secretPassword() {
  var password = 'xh38sk';
  return {
    guessPassword: function(guess) {
      if (guess === password) {
        return true;
      } else {
        return false;
      }
    }
  }
}

var passwordGame = secretPassword();
passwordGame.guessPassword('heyisthisit?'); // false
passwordGame.guessPassword('xh38sk'); // true
```

Это очень сильная техника -- это дает замыкающей функцией **guessPassword** исключительный доступ к переменной **password**, делая невозможным доступ к **password** снаружи.

## Tl;dr

- Контекст выполнения -- это абстрактный контекст использовавшийся в спецификации ECMAScript для отслеживания оценки времени выполнения кода. В любой момент времени может быть только один контекст выполнения, который выполненяет код.
- Каждый контекст исполнения имеет Лексическое окружение. Это Лексическое оркужение содержит привязки идентификатора (то есть переменные и их значения), и к тому же имеют ссылку на него во внешнем окружении.
- Набор идентификаторов, к которым у каждого окружения есть доступ, называют "областью видимости". Мы можем вложить эти области в иерархическую цепь окружения, известной как “цепь области видимости”.
- Каждая функция имеет контекст выполнения, которая включает в себя Лексическое окружение, это дает значение переменным в пределах этой функции и ссылку на родительское окружение. И это означает, что функции "запоминают" окружение (или область видимости) потому что функции буквально ссылаются на это окружение. Это и есть замыкание.
- Замыкание создаются каждый раз при вызове закрытой внешней функции. Другими словами, внутренняя функция не будет возвращена для замыкания где была создана.
- Область видимости замыканий в JavaScript лексическая, её смысл определяется статично в зависимости от нахождения в исходном коде.
- Есть множество практических случаев для использования замыканий. Один из важных случаев использования -- это сохранение приватных ссылок к переменным во внешней среде.

## Завершающая (замыкающая) ремарка

Я надеюсь этот пост был полезным и дал вам ментальную модель того, как замыкания реализованы в JavaScript. Как вы видите, понимание того, что такое гайки и болты, и как они работают, делают поиск замыканий проще -- и у вас будет меньше головной боли при отладке.

PS: Я человек и могу ошибаться (а переводчик тем более!) и если вы нашли ошибку -- дайте об этом знать!

### Дополнительная литература

Для краткости я опустила несколько тем, которые могут быть интересны для некоторых читателей. Вот несколько ссылок, которыми я хотела бы поделиться:

- **Какие среды переменных бывают в контексте выполнения?** Dr. Axel Rauschmayer сделал феноменальную объясняющую работу по этой теме, и я просто оставлю ссылку на его пост:
http://www.2ality.com/2011/04/ecmascript-5-spec-lexicalenvironment.html
- **Что является различнми типами записи окружения?** Читайте спецификацию здесь: http://www.ecma-international.org/ecma-262/6.0/#sec-environment-records
- **Отличная статья на MDN про замыкания** https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures
- Есть что-то еще? Предлагайте!
