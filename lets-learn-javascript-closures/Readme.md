*Перевод статьи Preethi Kasireddy:* https://medium.freecodecamp.com/lets-learn-javascript-closures-66feb44f6a44#.i3kdfkj4t

# Давайте выучим замыкания в Javascript

Замыкания являются одними из ключевых особенностей в JS, которые каждый уважающий себя программист должен знать наизусть.

В интернете есть множество объяснений тому "что" из себя представляют замыкания, но мало кто рассказывает "почему" они такие.

Я думаю, что понимание разработчиками принципов работы тех или иных особенностей языка, в конечном итоге, дает им более глубокое знание инструментов, поэтому этот пост будет посвящён внутреннему устройству замыканий -- как и почему они работают, как они это делают.

Надеюсь после этой статьи вы будете использовать больше замыканий в своей повседневной разработке. Давайте начнем!

## Что такое замыкания?

Замыкания являются мощным свойством в JavaScript (и других языках программирования). Вот определение с [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures)

>Замыкания — это **функции, ссылающиеся на независимые (свободные) переменные**. Другими словами, функция, определённая в замыкании, **«запоминает» окружение, в котором она была создана**.

*Заметка: Свободные переменные -- это переменные, которые не объявлены в локальной области видимости, а передаются как параметр.*

Давайте посмотрим на несколько примеров:

### Пример 1

```javascript
function numberGenerator() {
  // Локальная "свободная" переменная которая доступна только в замыкании
  var num = 1;
  function checkNumber() {
    console.log(num);
  }
  num++;
  return checkNumber;
}

var number = numberGenerator();
number(); // 2
```

В примере выше, функция `numberGenerator` создает локальную "свободную" переменную **num** (число) и **checkNumber** (функция, которая выводит число в консоль). Функция **checkNumber** не содержит в себе какой-нибудь собственной локальной переменной, но она имеет доступ к переменным внутри другой функции, **numberGenerator**, из-за замыкания.

### Пример 2

В этом примере мы покажем, что замыкания содержат в себе все локальные переменные, которые были объявлены внутри внешних замкнутых функций (enclosing function).

```javascript
function sayHello() {
  var say = function() { console.log(hello); }
  // Локальная переменная которая доступна только в замыкании
  var hello = 'Hello, world!';
  return say;
}
var sayHelloClosure = sayHello();
sayHelloClosure(); // ‘Hello, world!’
```
Обратите внимание как переменная **hello** определяется _после_ анонимной функции, но все еще может получить доступ к переменной **hello**. Это происходит из-за того, что переменная **hello** уже была определенна в области видимости(“scope”) во время создания, сделав ее доступной на тот момент, когда анонимная функция будет выполнена. (Не беспокойтесь, позже я объясню что такое "область видимости". А сейчас просто смиритесь с этим!:))

### Понимаем высокий уровень

Эти примеры показали нам "почему" замыкания находятся на высоком уровне. Главная мысль такая: *мы имеем доступ к переменным, которые были определены в замкнутых функциях и описывают их переменные как возвращенные*. Очевидно, что-то происходит в фоновом режиме, что делает эти переменные доступными после замкнутых функций, которые определяют и возвращают их.

Чтобы понять, как это работает, рассмотрим несколько связанных идей, поэтому мы зайдем издалека и медленно вернемся обратно к замыканиям. Давайте начнем наш путь с общего *контекста* в котором выполняется функция и который известен как *контекст выполнения* (Execution context).

## Контекст выполнения

Контекст выполнения -- это абстрактное понятие которое используется в спецификации ECMAScript для оценки времени выполнения кода. Это может быть глобальный контекст (global context), в котором ваш код выполнится первым или когда поток выполнения переходит в тело функции.

![](https://cdn-images-1.medium.com/max/800/1*_LacLIeET7asTTIKpHCawA.png)

*В любой момент может быть выполнен только один контекст выполнения функции.* Вот почему Javascript является "однопоточным", т.к единовременно может выполняться только одна команда. Обычно браузеры поддерживают этот контекст с помощью "стека" (stack). Стек -- структура данных, выполняемая в обратном порядке (LIFO -- «последним пришёл — первым вышел»). Последнее, что вы добавили в стек, будет удалено первым из него. (Это происходит из-за того, что мы можем только добавить или удалить элементы из верхушки стека). Данный (текущий) или "выполняющийся" контекст исполнения -- это всегда верхний элемент стека. Он выскакивает вверх когда код полностью определен при выполнении, позволяя следующему верхнему элементу стека взять на себя контекст выполнения.

Кроме того, если контекст исполнения уже выполняется, это вовсе не означает, что ему нужно завершить свое выполнение, прежде чем другой контекст выполнения сможет начать работу. Бывают случаи, когда контекст выполнения приостанавливается и другой контекст выполнения начинает работу. Прерванный контекст выполнения может быть позже забран обратно наверх в том месте, где он был приостановлен. В любое время один контекст выполнения может быть заменен другим и этот новый контекст поместится в стек, став текущим контекстом выполнения.

![](https://cdn-images-1.medium.com/max/800/1*M8VqttSMghsxyXcBo2Zz1w.png)

Для наглядности запустите в консоли код, который вы видите ниже:

```javascript
var x = 10;
function foo(a) {
  var b = 20;

  function bar(c) {
    var d = 30;
    return boop(x + a + b + c + d);
  }

  function boop(e) {
    return e * -1;
  }

  return bar;
}

var moar = foo(5); // Замыкание
/*
  Функция ниже выполняет функцию bar, которая была возвращена в тот момент,
  когда мы выполнили функцию foo в строке выше. Функция bar
  вызывает boop, в этот момент bar получает приостановку и boop перемещается
  на вершину стека вызовов(call stack) (см. скриншот ниже)
*/
moar(15);
```
![](https://cdn-images-1.medium.com/max/800/1*YWiyU5u3ONPrszk8QvHaqw.png)

Затем, когда **boop** возвратится, он удалится из стека и **bar** продолжит работу:

![](https://cdn-images-1.medium.com/max/800/1*MMgltiRSX6zGyCPQTM7CjA.png)

Когда у нас есть целая куча контекстов исполнения, которые работают одна за другой, часто бывают приостановлены в середине выполнения и потом снова запущены, то нужно как-то отслеживать их состояние, чтобы мы могли управлять последовательностью выполнения этих контекстов. Согласно спецификации ECMAScript, каждый контекст выполнения имеет разное состояние компонентов, которые используются для отслеживания прогресса кода в каждом контексте которое он сделал. К ним относятся:

 - **Оценка состояния кода** -- любое состояние необходимо выполнить, приостановить, и возобновить определение кода, связанного с этим контекстом исполнения
 - **Функция** -- объект функции, который оценивает контекст выполнения (или null если контекст выполнения был определен как *script* или *модуль*)
 - **Область** -- набор внутренних объектов, глобальное окружение ECMAScript, весь код ECMAScript, который находится в пределах этого глобального окружения, и другие связанные с ним состояния и ресурсы
 - **Лексическое окружение** -- используется для разрешения ссылок идентификатора кода в данном контексте исполнения.
 - **Переменное окружение** -- Лексическое окружение чья Запись окружения (EnvironmentRecord) имеет связи созданные Заявленными Переменными(VariableStatements) в этом контексте выполнения.

Не волнуйтесь, если это звучит слишком запутанно. Из всех этих переменных, переменные Лексического окружения наиболее интересны для нас, ведь они явно указывают, что принимают *идентификатор ссылки* кода в этом контексте выполнения. Вы можете думать о "идентификаторах" как о переменных. Так как наша первоначальная цель состояла в том, чтобы выяснить, как это возможно, что мы получаем доступ к переменным, даже после того, как функция (или "контекст") была возвращена и Лексическая Область Видимости то, что мы должны копнуть еще глубже.

***Заметка:*** Технически, и Окружение Переменных и Лексическая Область Видимости используются для реализации замыканий. Но для простоты, мы обобщим его на "Окружение". Для детального объяснения разницы между Лексическим и Переменным окружением читайте статью Dr.Alex Rauschmayer’s [здесь](http://www.2ality.com/2011/04/ecmascript-5-spec-lexicalenvironment.html)

## Лексическая область видимости

Дадим определение: *Лексическое окружение -- специфичный тип, используемый для связи Идентификаторов с определенными переменными и функциями на основе лексической структуры вложенности кода ECMAScript. Лексическое окружение состоит из Записи окружения (Environment Record) и, возможно, нулевой ссылки на внешнее Лексическое окружение. Обычно Лексическое окружение связано с определенной синтаксической структурой, например FunctionDeclaration (Объявление функции), BlockStatement (оператор блока), Catch clause (условный оператор), TryStatement (Перехват ошибок) и новым Лексическим окружением которое создавалось каждый раз при вычислении кода. -- [ ECMAScript-262/6.0](http://www.ecma-international.org/ecma-262/6.0/#sec-lexical-environments)*

Давайте разберем это.

- ***"используемый для связи Идентификаторов"***: целью Лексического Окружения является управлением данными (т.е. идентификаторами) в коде. Говоря иначе, это придает им смысл. Например, если бы у нас была такая строка в консоли *“console.log(x / 10)”*, то это была бы бессмысленная переменная (или идентификатор) *x* без чего-либо, что придавало этой переменной смысл. Лексическое окружение обеспечивает смысл (или "ассоциацию") через Запись Окружения. (смотрите ниже).

- ***Лексическое окружение состоит из Записи окружения***: Запись Окружения это причудливый способ сказать, что она хранит записи всех идентификаторов и связей, которые существуют в Лексической Области Видимости. Каждая Лексическая Область Видимости имеет свою собственную Запись Окружения.

- ***Лексическая структура вложенности***: это самый интересный момент, который говорит, что внутреннее окружение ссылается на внешнее окружение и это внешнее окружение может иметь своё собственное внешнее окружение. В результате окружение может быть внешним окружением для более чем одного внутреннего окружения. Глобальное окружение является единственным лексическим окружением, которое не имеет внешнего окружения. Это сложно описать словами, поэтому давайте использовать метафоры и представим лексическое окружение как слои лука: глобальная среда -- это внешний слой луковицы, каждый последующий слой находится ниже.

![](https://cdn-images-1.medium.com/max/1600/1*WIBH8HW9WzoKfBsQPGFHHg.png)

Так выглядит Окружение в псевдокоде:

```javascript
LexicalEnvironment = {
  EnvironmentRecord: {
  // Identifier bindings go here
  // Здесь идет привязка идентификатора
  },

  // Reference to the outer environment
  // Ссылка на внешнее окружение
  outer: < >
};
```

- ***Новое Лексическое окружение которое создавалось каждый раз при вычислении кода*** - каждый раз, когда внешние вложенные функции были вызваны, создается новое Лексическое окружение. Это важно -- мы вернемся к этому моменту в конце. (*Примечание: функции - не единственный способ создать Лексическое окружение. Другие содержат в себе оператор блока(block statement) или условный оператор(catch clause). Для простоты, я сосредоточусь на окружении созданной нами функции на протяжении всего поста*)

Каждый контекст исполнения имеет собственное Лексическое окружение. Это Лексическое окружение содержит переменные и связанные с ними значения, а так же имеет ссылку на него во внешнем окружении. Лексическое окружение может быть глобальным окружением, модульным окружением (которая содержит привязку для объявлений на высшем уровне объявлении Модуля) или окружение функций (окружение создается за счет вызова функции).

## Цепочки областей видимости

Исходя из приведенного выше определения, мы знаем, что окружение имеет доступ к окружению своего родителя, его родительское окружение имеет доступ к своему родительскому окружению и так далее. Этот набор идентификаторов, к которому каждое окружение имеет доступ называется "область видимости"(scope). Мы можем вложить их в иерархические цепочки окружения, известные как "цепочки областей видимости".

Давайте рассмотрим эту структуру вложенности:

```javascript
var x = 10;

function foo() {
  var y = 20; // свободная переменная
  function bar() {
    var z = 15; // свободная переменная
    return x + y + z;
  }
  return bar;
}
```

Как вы можете видеть, **bar** вложен в **foo**. Чтобы вы смогли всё это представить посмотрите на диаграмму ниже:

![](https://cdn-images-1.medium.com/max/1600/1*CwxZxltknV8DEEm_Y_ykfA.png)

Мы вернемся позже к этому примеру.

Эта цепочка области видимости, или цепочка окружения связанная с функцией, сохраняется в объекте функции в момент создания. Другими словами, она определяется статично по местоположению в исходном коде. (Это называют "лексической областью видимости").

Давайте быстренько разберем разницу между "динамической областью видимости" и "статической областью видимости, которая поможет нам разобраться, почему статическая область видимости (или лексическая область видимости) необходима для использования замыкания.

## Идем в обход: Динамическая область видимости против Статической области видимости

Динамические языки имеют "стек на основе реализации" -- локальные переменные и функции хранятся в стеке. Поэтому, во время выполнения стека, программа определяет какую переменную вы имеете в виду. С другой стороны, статическая область видимости -- это когда переменные ссылаются на контекст и фиксируются на *момент создания*. Другими словами, структура исходного кода программы определяет к каким переменным вы обращаетесь.

При этом Вы могли задаваться вопросом, как Динамическая и Статическая область видимости различаются. Вот два примера, которые помогут это проиллюстрировать:

### Пример 1

```javascript
var x = 10;

function foo() {
  var y = x + 5;
  return y;
}

function bar() {
  var x = 2;
  return foo();
}

function main() {
  foo(); // Static scope: 15; Dynamic scope: 15
  bar(); // Static scope: 15; Dynamic scope: 7
  return 0;
}
```

Как мы видим из примера выше, Статическая и Динамическая область видимости возвращают разные значения при вызове функции **bar**.

В статической области видимости возврат значения **bar** зависит от значения **x**. Это происходит из-за того, что статическая и лексическая структура исходного кода приводит **x** и к 10, и к 15.

Динамическая область видимости дает нам стек определенных переменных отслеживаемых во время выполнения. Поэтому **x**, которую мы используем, зависит от того,что находится в области видимости и как она была динамично определена во время выполнения. Выполнение функции **bar** выталкивает `x = 2` на верхушку стека, заставляя **foo** вернуть 7.

### Пример 2

```javascript
var myVar = 100;

function foo() {
  console.log(myVar);
}

foo(); // Static scope: 100; Dynamic scope: 100

(function () {
  var myVar = 50;
  foo(); // Static scope: 100; Dynamic scope: 50
})();

// Функция высшего порядка
(function (arg) {
  var myVar = 1500;
  arg();  // Static scope: 100; Dynamic scope: 1500
})(foo);
```

Аналогично и в Динамической области видимости. Переменная **myVar** решает какое использовать значение **myVar** в зависимости от того, где была вызвана функция. Статическая область видимости приводит **myVar** к переменной которая была сохранена в рамках двух немедленно вызываемых функций при их создании.

Как вы можете заметить, Динамическая область видимости часто приводит к некоторой двусмысленности. Она не дает точно понять какая свободная переменная будет передана.

## Замыкания

Вы можете подумать, что все, о чем мы говорим, совершенно не касается нашей темы, но на самом деле мы разобрали всё, что поможет нам понять замыкания:

> *Каждая функция имеет контекст выполнения, которая состоит из окружения, которое передает смысл в переменные этой функции и ссылку на окружение своего родителя. Ссылка на окружение родителя делает все переменные в родительской области доступными для всех внутренних функций, независимо от того, вызывается ли внутренняя функция(или функции) вне или внутри области видимости, в которой они были созданы.*
>
> *Кажется как-будто функция “помнит” это окружение, поскольку функция буквально имеет ссылку к области видимости (и переменным, определенным в этой среде)!*

Возвращаясь к примеру вложенной структуры:

```javascript
var x = 10;

function foo() {
  var y = 20; // свободная переменная
  function bar() {
    var z = 15; // свободная переменная
    return x + y + z;
  }
  return bar;
}

var test = foo();

test(); // 45
```

Основываясь на нашем понимании того, как работает окружение, мы можем сказать, что определение окружения для вышеупомянутого примера выглядит примерно так (примечание: это псевдокод):

```javascript
GlobalEnvironment = {
  EnvironmentRecord: {
    // встроенные идентификаторы
    Array: '<func>',
    Object: '<func>',
    // и т.д.

    // пользовательские идентификаторы
    x: 10
  },
  outer: null
};

fooEnvironment = {
  EnvironmentRecord: {
    y: 20,
    bar: '<func>'
  }
  outer: GlobalEnvironment
};

barEnvironment = {
  EnvironmentRecord: {
    z: 15
  }
  outer: fooEnvironment
};
```
Когда мы вызываем функцию **test**, мы получаем 45, которая возращает значением из вызова функции **bar** (потому что **foo** возвращает **bar**). **bar** имеет доступ к свободной переменной **y** даже после того, как функция **foo** вернется, потому что **bar** имеет ссылку на **y** через его внешнее окружение, которое является окружением **foo**! **bar** так же имеет доступ к глобальной переменной **x** потому что у окружения **foo** есть доступ к глобальному окружению. Это называют *"поиск цепочки области видимости"*.

Возвращаясь к нашему обсуждению Динамической области видимости против Статической: для замыканий, которые будут выполняться, нельзя использовать динамичеcкую область с помощью динамического стека для сохранности наших переменных. Причина в том, что когда функция возвращается, переменные будут удалены из стека и больше не будут доступны, что противоречит нашему определению замыкания. Это происходит из-за того, что замкнутость данных в родительском контексте сохраняется в том, что называется "кучей" и это позволяет сохранять данные после вызова функции, делая их возможными для возврата (т.е. даже после того, как контекст выполнения извлекается из стека выполнения вызова).

Все понятно? Хорошо. Теперь, когда мы понимаем внутренности на абстрактном уровне, давайте рассмотрим еще пару примеров:

### Пример 1

Вот типичное заблуждение: в цикле for мы пробуем связать переменную счетчика с какой-то функцией.

```javascript
var result = [];

for (var i = 0; i < 5; i++) {
  result[i] = function () {
    console.log(i);
  };
}

result[0](); // 5, ожидалось 0
result[1](); // 5, ожидалось 1
result[2](); // 5, ожидалось 2
result[3](); // 5, ожидалось 3
result[4](); // 5, ожидалось 4
```

Возвращаясь к тому, что мы изучили ранее, становится очень легко найти ошибку здесь! Абстрактно говоря, вот как выглядит окружение, во время выхода из цикла for:

```javascript
environment: {
  EnvironmentRecord: {
    result: [...],
    i: 5
  },
  outer: null,
}
```
Было бы неверно предполагать, что область видимости отличается для всех пяти функций в массиве результата. Вместо того, что фактически происходит, окружение (или контекст/область видимости) является тем же самым для всех пяти функций в пределах результирующего массива. Поэтому, каждый раз, когда переменная **i** увеличивается, обновляется область видимости, а она является общей для всех функций. Именно поэтому любая из 5 функций, пытающихся получить доступ к **i** возвращает 5. (i равна 5 когда цикл завершается).

Есть только один способ исправить это -- создать дополнительный вызываемый контекст для каждой функции, чтобы у каждой появился свой собственный контекст/область видимости.

```javascript
var result = [];

for (var i = 0; i < 5; i++) {
  result[i] = (function inner(x) {
    // дополнительный вызываемый контекст
    return function() {
      console.log(x);
    }
  })(i);
}

result[0](); // 0, ожидалось 0
result[1](); // 1, ожидалось 1
result[2](); // 2, ожидалось 2
result[3](); // 3, ожидалось 3
result[4](); // 4, ожидалось 4
```

Да! Мы пофиксили это :)

Есть еще один подход который заключается в том, что мы используем **let** вместо **var**, так **let** в операторе блока и поэтому новая привязка идентификатора замыкания создается для каждой итерации в цикле for.

```javascript
var result = [];

for (let i = 0; i < 5; i++) {
  result[i] = function () {
    console.log(i);
  };
}

result[0](); // 0, ожидалось 0
result[1](); // 1, ожидалось 1
result[2](); // 2, ожидалось 2
result[3](); // 3, ожидалось 3
result[4](); // 4, ожидалось 4

```

Tada! :)

### Пример 2

В этом примере мы покажем как каждый *call* в функции создает новое отдельное замыкание:

```javascript
function iCantThinkOfAName(num, obj) {
  // Это массив переменных, вместе с 2 параметрами, передаваемых
  // "захваченными" в замкнутую функцию 'doSomething'
  var array = [1, 2, 3];
  function doSomething(i) {
    num += i;
    array.push(num);
    console.log('num: ' + num);
    console.log('array: ' + array);
    console.log('obj.value: ' + obj.value);
  }

  return doSomething;
}

var referenceObject = { value: 10 };
var foo = iCantThinkOfAName(2, referenceObject); // замыкание #1
var bar = iCantThinkOfAName(6, referenceObject); // замыкание #2

foo(2);
/*
  num: 4
  array: 1,2,3,4
  obj.value: 10
*/

bar(2);
/*
  num: 8
  array: 1,2,3,8
  obj.value: 10
*/

referenceObject.value++;

foo(4);
/*
  num: 8
  array: 1,2,3,4,8
  obj.value: 11
*/

bar(4);
/*
  num: 12
  array: 1,2,3,8,12
  obj.value: 11
*/
```

В этом примере мы видим как, каждый раз, вызов в функции **iCantThinkOfAName** создает новое замыкание, а именно **foo** и **bar**.
Последующие вызовы каждой замкнутой функции обновляют замкнутые переменные в пределах самого замыкания, демонстрируя, что перемнные в *каждом* замыкании используются **iCantThinkOfAName’s doSomething** функциями после того, как вернулась **iCantThinkOfAName**.

### Пример 3

```javascript
function mysteriousCalculator(a, b) {
	var mysteriousVariable = 3;
	return {
		add: function() {
			var result = a + b + mysteriousVariable;
			return toFixedTwoPlaces(result);
		},

		subtract: function() {
			var result = a - b - mysteriousVariable;
			return toFixedTwoPlaces(result);
		}
	}
}

function toFixedTwoPlaces(value) {
	return value.toFixed(2);
}

var myCalculator = mysteriousCalculator(10.01, 2.01);
myCalculator.add() // 15.02
myCalculator.subtract() // 5.00
```

Вы можете видеть что **mysteriousCalculator** находится в глобальной области и возвращает две функции. Абстрактно говоря, окружение для кода выше будет выглядеть так:

```javascript

GlobalEnvironment = {
  EnvironmentRecord: {
    // встроенные идентификаторы
    Array: '<func>',
    Object: '<func>',
    // и т.д.

    // пользовательские идентификаторы
    mysteriousCalculator: '<func>',
    toFixedTwoPlaces: '<func>',
  },
  outer: null,
};

mysteriousCalculatorEnvironment = {
  EnvironmentRecord: {
    a: 10.01,
    b: 2.01,  
    mysteriousVariable: 3,
  }
  outer: GlobalEnvironment,
};

addEnvironment = {
  EnvironmentRecord: {
    result: 15.02
  }
  outer: mysteriousCalculatorEnvironment,
};

subtractEnvironment = {
  EnvironmentRecord: {
    result: 5.00
  }
  outer: mysteriousCalculatorEnvironment,
};
```

Это происходит из-за того, что наши функции **add** и **substract** ссылаются на среду **mysteriousCalculator** и они в состоянии использовать переменные той среды для расчета результата.

### Пример 4

Последний пример продемонстрирует важность использования замыканий: для поддержания собственной ссылки на переменную во внешней области видимости.

```javascript
function secretPassword() {
  var password = 'xh38sk';
  return {
    guessPassword: function(guess) {
      if (guess === password) {
        return true;
      } else {
        return false;
      }
    }
  }
}

var passwordGame = secretPassword();
passwordGame.guessPassword('heyisthisit?'); // false
passwordGame.guessPassword('xh38sk'); // true
```

Это очень сильная техника -- это дает замыкающей функцией **guessPassword** исключительный доступ к переменной **password**, делая невозможным доступ к **password** снаружи.

## Tl;dr

- Контекст выполнения -- это абстрактный контекст использовавшийся в спецификации ECMAScript для отслеживания оценки времени выполнения кода. В любой момент времени может быть только один контекст выполнения, который выполняет код.
- Каждый контекст исполнения имеет Лексическое окружение. Это Лексическое окружение содержит привязки идентификатора (то есть переменные и их значения), и к тому же имеют ссылку на него во внешнем окружении.
- Набор идентификаторов, к которым у каждого окружения есть доступ, называют "областью видимости". Мы можем вложить эти области в иерархическую цепь окружения, известной как “цепь области видимости”.
- Каждая функция имеет контекст выполнения, которая включает в себя Лексическое окружение, это дает значение переменным в пределах этой функции и ссылку на родительское окружение. И это означает, что функции "запоминают" окружение (или область видимости) потому что функции буквально ссылаются на это окружение. Это и есть замыкание.
- Замыкание создаются каждый раз при вызове закрытой внешней функции. Другими словами, внутренняя функция не будет возвращена для замыкания где была создана.
- Область видимости замыканий в JavaScript лексическая, её смысл определяется статично в зависимости от нахождения в исходном коде.
- Есть множество практических случаев для использования замыканий. Один из важных случаев использования -- это сохранение приватных ссылок к переменным во внешней среде.

## Завершающая (замыкающая) ремарка

Я надеюсь этот пост был полезным и дал вам визуальную модель того, как замыкания реализованы в JavaScript. Как вы видите, понимание того, что такое внутреннее устройство замыканий, и как они работают, делают их поиск проще. У вас будет меньше головной боли при отладке!

## Дополнительная литература

Для краткости я опустила несколько тем, которые могут быть интересны для некоторых читателей. Вот несколько ссылок, которыми я хотела бы поделиться:

- **Какие среды переменных бывают в контексте выполнения?** Dr. Axel Rauschmayer сделал феноменальную объясняющую работу по этой теме, и я просто оставлю ссылку на его пост:
http://www.2ality.com/2011/04/ecmascript-5-spec-lexicalenvironment.html
- **Что является различными типами записи окружения?** Читайте спецификацию здесь: http://www.ecma-international.org/ecma-262/6.0/#sec-environment-records
- **Отличная статья на MDN про замыкания** https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures
- Есть что-то еще? Предлагайте!
